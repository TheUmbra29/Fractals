import sys
import os

# Configurar path para imports absolutos
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)

# IMPORTS CORRECTOS seg√∫n tu estructura REAL
from infrastructure.ui.game_loop import GameLoop
from infrastructure.persistence.repositories.in_memory_battle_repository import InMemoryBattleRepository
from core.domain.services.turn_service import TurnService

def main():
    """Solo ensambla y inicia"""
    print("üéÆ FRACTALS - Composition Root")
    print("üõ£Ô∏è  Sistema de trazado de ruta + PH/TdE activado")
    
    # Ensamblar dependencias
    battle_repo = InMemoryBattleRepository()
    turn_service = TurnService(battle_repo)
    game_loop = GameLoop(battle_repo, turn_service)
    
    # Iniciar
    game_loop.run()

if __name__ == "__main__":
    main()
from core.domain.entities.value_objects.game_enums import Team, CharacterClass
from core.domain.entities.value_objects.position import Position
from core.domain.entities.value_objects.stats import EntityStats
from core.domain.entities.value_objects.entity_id import EntityId
from core.domain.entities.battle_entity import BattleEntity

# Crear entidades como en el juego
ricchard = BattleEntity(
    entity_id=EntityId.generate(),
    position=Position(1, 1),
    stats=EntityStats(100, 100, 50, 50, 25, 15, 10),
    team=Team.PLAYER,
    name="Ricchard",
    character_class=CharacterClass.DAMAGE
)
enemy = BattleEntity(
    entity_id=EntityId.generate(),
    position=Position(6, 6),
    stats=EntityStats(80, 80, 30, 30, 20, 10, 8),
    team=Team.ENEMY,
    name="Enemy Bot",
    character_class=CharacterClass.DAMAGE
)

# Simular ciclo de renderizado
for entity in [ricchard, enemy]:
    print(f"[DEBUG] Renderizando entidad: name={entity.name}, id={entity.id}, team={repr(entity.team)}, type={type(entity.team)}")
    is_player = entity.team == Team.PLAYER or (isinstance(entity.team, str) and entity.team.upper() == "PLAYER")
    print(f"  ¬øSe pinta azul? {is_player}")
# Character Entity
# Character Class Value Object
# CharacterId Value Object
# Character Repository Interface
# Character Factory
# In Memory Character Repository
# Ability Info DTO
"""
DTO para estado de batalla
"""
from dataclasses import dataclass
from typing import Dict, List, Any
from uuid import UUID

@dataclass
class BattleStateDTO:
    """DTO para transferir estado de batalla a la UI"""
    battle_id: UUID
    mode: str
    turn_count: int
    current_turn: str
    actions_remaining: int
    wave_number: int
    is_completed: bool
    entities: List[Dict[str, Any]]
# Entity Info DTO
from abc import ABC, abstractmethod
from typing import List
from ...domain.events.domain_event import DomainEvent

class EventPublisherPort(ABC):
    """Puerto para publicar eventos de dominio"""
    
    @abstractmethod
    def publish(self, event: DomainEvent) -> None:
        """Publica un evento de dominio"""
        pass
    
    @abstractmethod
    def publish_all(self, events: List[DomainEvent]) -> None:
        """Publica m√∫ltiples eventos de dominio"""
        pass
from abc import ABC, abstractmethod
from typing import Tuple, List, Callable

class InputPort(ABC):
    """Puerto de entrada - abstracci√≥n para manejar input del usuario"""
    
    @abstractmethod
    def get_mouse_position(self) -> Tuple[int, int]:
        pass
    
    @abstractmethod
    def is_mouse_clicked(self) -> bool:
        pass
    
    @abstractmethod
    def get_key_events(self) -> List[str]:
        pass
    
    @abstractmethod
    def process_events(self) -> None:
        pass
    
    @abstractmethod
    def subscribe(self, observer: Callable) -> None:
        pass
from abc import ABC, abstractmethod
from typing import Dict, Any

class RenderingPort(ABC):
    """Puerto de renderizado - abstracci√≥n para mostrar el juego"""
    
    @abstractmethod
    def initialize(self) -> None:
        pass
    
    @abstractmethod
    def render_battle(self, battle_state: Dict[str, Any]) -> None:
        pass
    
    @abstractmethod
    def cleanup(self) -> None:
        pass
from .input_port import InputPort
from .rendering_port import RenderingPort
from .event_publisher_port import EventPublisherPort

__all__ = [
    "InputPort",
    "RenderingPort", 
    "EventPublisherPort"
]
from dataclasses import dataclass
from uuid import UUID

@dataclass
class EndTurnCommand:
    """Comando para terminar el turno actual"""
    battle_id: UUID
from dataclasses import dataclass
from uuid import UUID
from ....domain.entities.value_objects.entity_id import EntityId
from ....domain.entities.value_objects.ability_id import AbilityId
from ....domain.entities.value_objects.position import Position

@dataclass
class ExecuteAbilityCommand:
    """Comando para ejecutar una habilidad"""
    battle_id: UUID
    caster_id: EntityId
    ability_id: AbilityId
    target_id: EntityId = None
    target_position: Position = None
from dataclasses import dataclass
from uuid import UUID
from ....domain.entities.value_objects.entity_id import EntityId
from ....domain.entities.value_objects.position import Position

@dataclass
class MoveEntityCommand:
    """Comando para mover una entidad con posible embestida"""
    battle_id: UUID
    entity_id: EntityId
    target_position: Position
    dash_targets: list = None  # Lista de enemigos a embestir

    def __post_init__(self):
        if self.dash_targets is None:
            self.dash_targets = []
from .....domain.repositories.battle_repository import BattleRepository
from ..end_turn_command import EndTurnCommand

class EndTurnHandler:
    """Manejador para terminar el turno"""
    
    def __init__(self, battle_repository: BattleRepository):
        self.battle_repository = battle_repository
    
    def handle(self, command: EndTurnCommand):
        battle = self.battle_repository.get_by_id(command.battle_id)
        
        # Forzar el fin del turno del jugador
        events = []
        while battle.actions_remaining > 0:
            turn_events = battle.consume_player_action()
            events.extend(turn_events)
        
        self.battle_repository.save(battle)
        return events
# Execute Ability Handler
from .....domain.repositories.battle_repository import BattleRepository
from .....domain.services.movement_validation_service import MovementValidationService
from ..move_entity_command import MoveEntityCommand

class MoveEntityHandler:
    """Manejador para el comando de mover entidad"""
    
    def __init__(self, battle_repository: BattleRepository):
        self.battle_repository = battle_repository
    
    def handle(self, command: MoveEntityCommand):
        # 1. Cargar el agregado Battle
        battle = self.battle_repository.get_by_id(command.battle_id)
        
        # 2. Obtener la entidad
        entity = battle.get_entity(command.entity_id)
        if not entity:
            raise ValueError("Entidad no encontrada")
        
        # 3. Validar movimiento
        obstacles = battle._obstacles
        all_entities = list(battle._entities.values())
        if not MovementValidationService.validate_movement_path(
            entity.position, command.target_position, obstacles, all_entities
        ):
            raise ValueError("Movimiento no v√°lido")
        
        # 4. Mover la entidad
        entity.move_to(command.target_position)
        
        # 5. Procesar embestidas
        events = []
        for enemy_id in command.dash_targets:
            enemy = battle.get_entity(enemy_id)
            if enemy and enemy.team != entity.team:
                dash_events = entity.execute_dash_attack(enemy)
                events.extend(dash_events)
        
        # 6. Marcar acci√≥n usada
        entity.mark_action_used("move")
        
        # 7. Consumir acci√≥n del turno
        battle.consume_player_action()
        
        # 8. Guardar cambios
        self.battle_repository.save(battle)
        
        # 9. Devolver eventos
        return events
from dataclasses import dataclass
from uuid import UUID

@dataclass
class GetBattleStateQuery:
    """Query para obtener el estado completo de la batalla"""
    battle_id: UUID
from dataclasses import dataclass
from uuid import UUID
from ....domain.entities.value_objects.entity_id import EntityId

@dataclass
class GetEntityInfoQuery:
    """Query para obtener informaci√≥n de una entidad espec√≠fica"""
    battle_id: UUID
    entity_id: EntityId
from .....domain.repositories.battle_repository import BattleRepository
from ..get_battle_state_query import GetBattleStateQuery

class GetBattleStateHandler:
    """Manejador para obtener el estado de la batalla"""
    
    def __init__(self, battle_repository: BattleRepository):
        self.battle_repository = battle_repository
    
    def handle(self, query: GetBattleStateQuery):
        battle = self.battle_repository.get_by_id(query.battle_id)
        
        # Convertir el agregado Battle a un DTO simple para la UI
        return {
            "battle_id": str(battle.id),
            "mode": battle.mode,
            "turn": battle.turn_count,
            "current_turn": battle.current_turn,
            "actions_remaining": battle.actions_remaining,
            "wave_number": battle.wave_number,
            "is_completed": battle.is_completed,
            "entities": [
                {
                    "id": str(entity.id),
                    "name": entity.name,
                    "position": {"x": entity.position.x, "y": entity.position.y},
                    "stats": {
                        "current_hp": entity.stats.current_hp,
                        "max_hp": entity.stats.max_hp,
                        "current_ph": entity.stats.current_ph,
                        "max_ph": entity.stats.max_ph,
                        "attack": entity.stats.attack,
                        "defense": entity.stats.defense,
                        "speed": entity.stats.speed
                    },
                    "team": entity.team,
                    "class": entity.character_class,
                    "has_acted": entity.has_acted,
                    "has_moved": entity.has_moved
                }
                for entity in battle._entities.values()
            ]
        }
# Get Entity Info Handler
from dataclasses import dataclass, field
from typing import Tuple, Dict, Any

@dataclass(frozen=True)
class GameConfig:
    """Configuraci√≥n centralizada del juego - INMUTABLE"""
    
    # Grid y movimiento
    GRID_SIZE: Tuple[int, int] = (8, 8)
    MAX_MOVEMENT_RANGE: int = 999
    ACTIONS_PER_TURN: int = 3
    
    # Equipos
    PLAYER_TEAM: str = "player"
    ENEMY_TEAM: str = "enemy"
    
    # Da√±os y balance
    BASE_DASH_DAMAGE: int = 15
    BASE_ATTACK_DAMAGE: int = 25
    PH_RECOVERY_RATE: float = 0.2
    
    # Posiciones iniciales
    INITIAL_OBSTACLES: Tuple[Tuple[int, int], ...] = (
        (3, 3), (4, 4), (2, 5)
    )
    
    # Stats base por clase - ‚úÖ CORREGIDO: usar default_factory
    CLASS_STATS: Dict[str, Dict[str, int]] = field(
        default_factory=lambda: {
            "Da√±o": {
                "max_hp": 100, "max_ph": 50, "attack": 25, "defense": 15, "speed": 10
            },
            "T√°ctico": {
                "max_hp": 80, "max_ph": 60, "attack": 20, "defense": 12, "speed": 12
            },
            "Apoyo": {
                "max_hp": 90, "max_ph": 70, "attack": 15, "defense": 18, "speed": 8
            }
        }
    )

# Instancia global √∫nica
GAME_CONFIG = GameConfig()
from typing import List, Optional, Set, Dict
from uuid import UUID

from .value_objects.position import Position
from .value_objects.stats import EntityStats
from .value_objects.entity_id import EntityId
from .value_objects.progression import Progression
from .value_objects.ability import Ability
from .value_objects.ability_id import AbilityId
from .value_objects.game_enums import Team, CharacterClass, ActionType
from ..events.domain_event import DomainEvent
from ..events.entity_damaged import EntityDamaged
from ..events.entity_died import EntityDied
from ..events.dash_executed import DashExecuted
from ..config.game_config import GAME_CONFIG

# Definir placeholders localmente para evitar importaci√≥n circular
class EntityLeveledUp(DomainEvent):
    def __init__(self, entity_id, old_level, new_level):
        self.entity_id = entity_id
        self.old_level = old_level
        self.new_level = new_level

class BattleEntity:
    """ENTIDAD RAIZ usando enums y configuraci√≥n"""

    def __init__(self, entity_id: EntityId, position: Position, stats: EntityStats, 
                 team: Team, name: str, character_class: CharacterClass, abilities: Dict[str, Ability] = None):
        self._id = entity_id
        self._position = position
        self._stats = stats
        self._team = team
        self._name = name
        self._character_class = character_class
        self._pending_events: List[DomainEvent] = []
        # Estado temporal del turno
        self._has_acted = False
        self._has_moved = False
        self._actions_used_this_turn: Set[ActionType] = set()
        self._dash_targets_this_move: Set[EntityId] = set()
        self._progression = Progression()
        self._abilities = abilities or self._get_default_abilities()

    # PROPIEDADES DE SOLO LECTURA
    @property
    def id(self) -> EntityId:
        return self._id
    
    @property
    def position(self) -> Position:
        return self._position
    
    @property
    def stats(self) -> EntityStats:
        return self._stats
    
    @property
    def team(self) -> str:
        return self._team
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def character_class(self) -> str:
        return self._character_class
    
    @property
    def has_acted(self) -> bool:
        return self._has_acted
    
    @property
    def has_moved(self) -> bool:
        return self._has_moved
    
    @property
    def actions_used_this_turn(self) -> Set[str]:
        return self._actions_used_this_turn
    
    @property
    def dash_targets_this_move(self) -> Set[EntityId]:
        return self._dash_targets_this_move
    
    @property
    def progression(self) -> Progression:
        return self._progression
    
    @property
    def abilities(self) -> Dict[str, Ability]:
        return self._abilities.copy()
    
    @property
    def current_ph(self) -> int:
        return self._stats.current_ph
    
    @property
    def max_ph(self) -> int:
        return self._stats.max_ph

    # COMPORTAMIENTO DEL DOMINIO
    def take_damage(self, damage_amount: int) -> List[DomainEvent]:
        """COMMAND: Modifica estado y produce eventos de dominio"""
        if not self._stats.is_alive():
            return []  # Entidades muertas no reciben da√±o
            
        old_hp = self._stats.current_hp
        self._stats = self._stats.reduce_hp(damage_amount)
        
        events = [EntityDamaged(
            entity_id=self._id,
            old_hp=old_hp,
            new_hp=self._stats.current_hp,
            damage_amount=damage_amount
        )]
        
        if not self._stats.is_alive():
            events.append(EntityDied(entity_id=self._id))
            
        self._pending_events.extend(events)
        return events

    def move_to(self, new_position: Position) -> None:
        """COMMAND: Mueve la entidad a una nueva posici√≥n"""
        if self._has_moved:
            raise ValueError(f"{self._name} ya se ha movido este turno")
            
        self._position = new_position
        self._has_moved = True
        self.mark_action_used("move")

    def execute_dash_attack(self, enemy: 'BattleEntity') -> List[DomainEvent]:
        """Embestida - mec√°nica central de FRACTALS"""
        if enemy.id in self._dash_targets_this_move:
            return []  # No embestir mismo enemigo dos veces en un mismo movimiento
            
        # Da√±o fijo de 15 seg√∫n especificaciones
        dash_damage = 15
        events = enemy.take_damage(dash_damage)
        self._dash_targets_this_move.add(enemy.id)
        
        events.append(DashExecuted(self.id, enemy.id, dash_damage))
        self._pending_events.extend(events)
        return events

    def mark_action_used(self, action_type: str) -> None:
        """Marca que se us√≥ una acci√≥n este turno"""
        self._actions_used_this_turn.add(action_type)

    def can_perform_action(self, action_type: str) -> bool:
        """Seg√∫n GDD: m√∫ltiples acciones pero no repetidas"""
        return action_type not in self._actions_used_this_turn

    def gain_experience(self, amount: int) -> List[DomainEvent]:
        """Progresi√≥n temporal - se reinicia al terminar sesi√≥n"""
        old_level = self._progression.level
        new_progression = self._progression.add_experience(amount)
        
        events = []
        if new_progression.level > old_level:
            events.append(EntityLeveledUp(self.id, old_level, new_progression.level))
            # Aqu√≠ podr√≠amos aplicar mejoras de nivel (aumentar stats, etc.)
            
        self._progression = new_progression
        self._pending_events.extend(events)
        return events

    def reset_turn_state(self) -> None:
        """COMMAND: Prepara la entidad para nuevo turno"""
        self._has_acted = False
        self._has_moved = False
        self._actions_used_this_turn.clear()
        self._dash_targets_this_move.clear()
        
        # Recuperar 20% de PH al inicio del turno (seg√∫n balance del GDD)
        ph_recovery = int(self._stats.max_ph * 0.2)
        self.restore_ph(ph_recovery)
        
        # Reducir cooldowns de habilidades
        self.reduce_ability_cooldowns()

    def clear_events(self) -> List[DomainEvent]:
        """Obtiene y limpia eventos pendientes"""
        events = self._pending_events.copy()
        self._pending_events.clear()
        return events

    # SISTEMA DE HABILIDADES CON PH Y TdE
    def _get_default_abilities(self) -> Dict[str, Ability]:
        """Habilidades por defecto usando configuraci√≥n de clases y enums"""
        base_abilities = {
            str(ActionType.BASIC_ATTACK): Ability(
                id=AbilityId.generate(),
                name="Ataque B√°sico",
                description="Ataque b√°sico sin costo de PH",
                ph_cost=0,
                cooldown_turns=0,
                damage_multiplier=1.0,
                range=1
            )
        }
        class_config = GAME_CONFIG.CLASS_STATS.get(str(self._character_class), {})
        if self._character_class == CharacterClass.DAMAGE:
            base_abilities.update({
                str(ActionType.ABILITY_ALPHA): Ability(
                    id=AbilityId.generate(),
                    name="Golpe Fren√©tico",
                    description=f"Ataque r√°pido - Da√±o: {class_config.get('attack', 25) * 1.5}",
                    ph_cost=20,
                    cooldown_turns=1,
                    damage_multiplier=1.5,
                    range=2
                ),
                # ... otras habilidades
            })
        # ... otras clases
        return base_abilities

    def can_use_ability(self, ability_type: str) -> bool:
        """Verifica si puede usar una habilidad seg√∫n PH y TdE"""
        if ability_type not in self._abilities:
            return False
            
        ability = self._abilities[ability_type]
        
        # Verificar PH suficiente
        if self._stats.current_ph < ability.ph_cost:
            return False
            
        # Verificar que no est√© en cooldown
        if ability.current_cooldown > 0:
            return False
            
        # Verificar que no haya usado esta habilidad este turno (seg√∫n GDD)
        if ability_type in self._actions_used_this_turn:
            return False
            
        return True

    def use_ability(self, ability_type: str, target: Optional['BattleEntity'] = None) -> List[DomainEvent]:
        """Usa una habilidad, consumiendo PH y aplicando cooldown"""
        if ability_type not in self._abilities:
            raise ValueError(f"Habilidad {ability_type} no existe")
            
        ability = self._abilities[ability_type]
        
        if not self.can_use_ability(ability_type):
            raise ValueError(f"No puede usar {ability_type}")
        
        events = []
        
        # Consumir PH
        if ability.ph_cost > 0:
            self._stats = self._stats.reduce_ph(ability.ph_cost)
        
        # Aplicar cooldown
        self._abilities[ability_type] = ability.use()
        
        # Marcar como usada este turno
        self.mark_action_used(ability_type)
        
        # Aplicar efecto de la habilidad
        if target and ability.damage_multiplier != 0:
            if ability.damage_multiplier > 0:
                # Habilidad de da√±o
                damage = int(self._stats.attack * ability.damage_multiplier)
                damage_events = target.take_damage(damage)
                events.extend(damage_events)
            else:
                # Habilidad de curaci√≥n/escudo (placeholder)
                heal_amount = int(self._stats.attack * abs(ability.damage_multiplier))
                # Aqu√≠ ir√≠a la l√≥gica de curaci√≥n - por ahora solo evento
                from ..events.entity_healed import EntityHealed
                events.append(EntityHealed(
                    entity_id=target.id,
                    heal_amount=heal_amount,
                    healer_id=self._id
                ))
        
        self._pending_events.extend(events)
        return events

    def reduce_ability_cooldowns(self):
        """Reduce todos los cooldowns en 1 (llamar al final del turno)"""
        for ability_type, ability in self._abilities.items():
            if ability.current_cooldown > 0:
                self._abilities[ability_type] = ability.reduce_cooldown()

    def restore_ph(self, amount: int):
        """Restaura PH (hasta el m√°ximo)"""
        new_ph = min(self._stats.max_ph, self._stats.current_ph + amount)
        self._stats = EntityStats(
            max_hp=self._stats.max_hp,
            current_hp=self._stats.current_hp,
            max_ph=self._stats.max_ph,
            current_ph=new_ph,
            attack=self._stats.attack,
            defense=self._stats.defense,
            speed=self._stats.speed
        )

    # IGUALDAD POR IDENTIDAD
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, BattleEntity):
            return False
        return self._id == other._id
    
    def __hash__(self) -> int:
        return hash(self._id)
    
    def __repr__(self) -> str:
        return f"BattleEntity({self._name}, {self._position}, HP: {self._stats.current_hp}/{self._stats.max_hp})"
from .battle_entity import BattleEntity

__all__ = ["BattleEntity"]
from typing import List, Dict, Optional, Set
from uuid import UUID, uuid4

from ..value_objects.entity_id import EntityId 
from ..value_objects.position import Position  
from ..value_objects.game_enums import Team, GameState
from ..battle_entity import BattleEntity
from ...events.domain_event import DomainEvent
from ...events.player_turn_started import PlayerTurnStarted
from ...events.player_turn_ended import PlayerTurnEnded
from ...events.enemy_turn_started import EnemyTurnStarted
from ...events.enemy_turn_ended import EnemyTurnEnded
from ...config.game_config import GAME_CONFIG

class Battle:
    """AGREGADO RAIZ - Representa una batalla completa en FRACTALS"""
    
    def __init__(self, battle_id: UUID, mode: str = "arcade", grid_size: tuple = None):
        self._id = battle_id
        self._mode = mode
        self._grid_size = grid_size or GAME_CONFIG.GRID_SIZE
        self._entities: Dict[EntityId, BattleEntity] = {}
        self._obstacles: Set[Position] = set()
        self._current_turn = Team.PLAYER
        self._turn_count = 1
        self._actions_remaining = GAME_CONFIG.ACTIONS_PER_TURN
        self._pending_events: List[DomainEvent] = []
        self._wave_number = 1
        self._is_completed = False

    # PROPIEDADES DE SOLO LECTURA
    @property
    def id(self) -> UUID:
        return self._id

    @property
    def mode(self) -> str:
        return self._mode

    @property
    def grid_size(self) -> tuple:
        return self._grid_size

    @property
    def current_turn(self) -> Team:
        return self._current_turn
    # NUEVOS M√âTODOS P√öBLICOS PARA ENCAPSULAMIENTO
    def get_entities(self) -> List[BattleEntity]:
        """Obtiene todas las entidades (copia)"""
        return list(self._entities.values())

    def get_obstacles(self) -> Set[Position]:
        """Obtiene todos los obst√°culos (copia)"""
        return self._obstacles.copy()

    def get_entity_count(self) -> int:
        """N√∫mero total de entidades"""
        return len(self._entities)

    def get_alive_entities_by_team(self, team: Team) -> List[BattleEntity]:
        """Obtiene entidades vivas de un equipo espec√≠fico"""
        return [entity for entity in self._entities.values() 
                if entity.team == team and entity.stats.is_alive()]

    @property
    def turn_count(self) -> int:
        return self._turn_count

    @property
    def actions_remaining(self) -> int:
        return self._actions_remaining

    @property
    def wave_number(self) -> int:
        return self._wave_number

    @property
    def is_completed(self) -> bool:
        return self._is_completed

    # GESTI√ìN DE ENTIDADES
    def add_entity(self, entity: BattleEntity) -> None:
        """A√±ade una entidad a la batalla"""
        self._entities[entity.id] = entity

    def get_entity(self, entity_id: EntityId) -> Optional[BattleEntity]:
        """Obtiene una entidad por su ID"""
        return self._entities.get(entity_id)

    def get_player_entities(self) -> List[BattleEntity]:
        """Obtiene todas las entidades del jugador"""
        return [entity for entity in self._entities.values() 
                if entity.team == Team.PLAYER]

    def get_enemy_entities(self) -> List[BattleEntity]:
        """Obtiene todas las entidades enemigas"""
        return [entity for entity in self._entities.values() 
                if entity.team == Team.ENEMY]

    def get_alive_player_entities(self) -> List[BattleEntity]:
        """Obtiene entidades del jugador que est√°n vivas"""
        return self.get_alive_entities_by_team(Team.PLAYER)

    def get_alive_enemy_entities(self) -> List[BattleEntity]:
        """Obtiene entidades enemigas que est√°n vivas"""
        return self.get_alive_entities_by_team(Team.ENEMY)

    # GESTI√ìN DE OBST√ÅCULOS/COBERTURA
    def add_obstacle(self, position: Position) -> None:
        """A√±ade una posici√≥n de obst√°culo/cobertura"""
        self._obstacles.add(position)

    def is_obstacle(self, position: Position) -> bool:
        """Verifica si una posici√≥n tiene un obst√°culo"""
        return position in self._obstacles

    # GESTI√ìN DE TURNOS Y ACCIONES (N√öCLEO DE FRACTALS)
    def consume_player_action(self) -> List[DomainEvent]:
        """Consume una acci√≥n del jugador usando configuraci√≥n"""
        if self._current_turn != Team.PLAYER:
            raise InvalidTurnError("No es el turno del jugador")
        if self._actions_remaining <= 0:
            raise NoActionsRemainingError("No quedan acciones este turno")
        self._actions_remaining -= 1
        events = []
        if self._actions_remaining <= 0:
            events.extend(self._end_player_turn())
        return events

    def _end_player_turn(self) -> List[DomainEvent]:
        """Finaliza el turno del jugador"""
        events = [PlayerTurnEnded(self._id, self._turn_count)]
        for entity in self.get_player_entities():
            entity.reset_turn_state()
        self._current_turn = Team.ENEMY
        events.append(EnemyTurnStarted(self._id, self._turn_count))
        events.extend(self._end_enemy_turn())
        return events

    def _end_enemy_turn(self) -> List[DomainEvent]:
        """Finaliza el turno de la IA"""
        events = [EnemyTurnEnded(self._id, self._turn_count)]
        for entity in self.get_enemy_entities():
            entity.reset_turn_state()
        self._current_turn = Team.PLAYER
        self._turn_count += 1
        self._actions_remaining = GAME_CONFIG.ACTIONS_PER_TURN
        events.append(PlayerTurnStarted(self._id, self._turn_count))
        events.extend(self._check_battle_conditions())
        return events
    def is_position_occupied_by_ally(self, position: Position, entity: BattleEntity) -> bool:
        """Verifica si una posici√≥n est√° ocupada por un aliado"""
        for other_entity in self._entities.values():
            if (other_entity.position == position and 
                other_entity.team == entity.team and
                other_entity.id != entity.id):
                return True
        return False

    def _check_battle_conditions(self) -> List[DomainEvent]:
        """Verifica condiciones de victoria/derrota seg√∫n el modo"""
        events = []
        
        alive_players = self.get_alive_player_entities()
        alive_enemies = self.get_alive_enemy_entities()
        
        # Modo Arcade: oleadas infinitas
        if self._mode == "arcade" and len(alive_enemies) == 0:
            self._wave_number += 1
            # En el futuro: generar nueva oleada de enemigos
            # events.append(NewWaveStarted(self._id, self._wave_number))
        
        # Victoria: todos los enemigos eliminados
        if len(alive_enemies) == 0:
            self._is_completed = True
            # events.append(BattleVictory(self._id))
            
        # Derrota: todos los jugadores eliminados  
        if len(alive_players) == 0:
            self._is_completed = True
            # events.append(BattleDefeat(self._id))
            
        return events

    # UTILIDADES
    def is_position_valid(self, position: Position) -> bool:
        """Verifica si una posici√≥n est√° dentro del grid"""
        return (0 <= position.x < self._grid_size[0] and 
                0 <= position.y < self._grid_size[1])

    def is_position_occupied(self, position: Position) -> bool:
        """Verifica si una posici√≥n est√° ocupada por una entidad"""
        return any(entity.position == position for entity in self._entities.values())

    def get_entity_at_position(self, position: Position) -> Optional[BattleEntity]:
        """Obtiene la entidad en una posici√≥n espec√≠fica"""
        for entity in self._entities.values():
            if entity.position == position:
                return entity
        return None

    def clear_events(self) -> List[DomainEvent]:
        """Obtiene y limpia los eventos pendientes"""
        events = self._pending_events.copy()
        self._pending_events.clear()
        return events

    def __repr__(self) -> str:
        return f"Battle(mode={self._mode}, turn={self._turn_count}, actions={self._actions_remaining}, entities={len(self._entities)})"

# EXCEPCIONES ESPEC√çFICAS DEL DOMINIO
class InvalidTurnError(Exception):
    pass

class NoActionsRemainingError(Exception):
    pass
from dataclasses import dataclass
from typing import Dict, Any, Optional
from .ability_id import AbilityId

@dataclass(frozen=True)
class Ability:
    """Value Object para representar una habilidad con PH y TdE"""
    id: AbilityId
    name: str
    description: str
    ph_cost: int
    cooldown_turns: int
    current_cooldown: int = 0
    ability_type: str = "active"  # "active", "passive", "ultimate"
    damage_multiplier: float = 1.0
    range: int = 1
    
    def is_available(self, current_ph: int) -> bool:
        """Verifica si la habilidad puede usarse"""
        return (current_ph >= self.ph_cost and 
                self.current_cooldown <= 0)
    
    def use(self) -> 'Ability':
        """Retorna una nueva instancia con cooldown aplicado"""
        return Ability(
            id=self.id,
            name=self.name,
            description=self.description,
            ph_cost=self.ph_cost,
            cooldown_turns=self.cooldown_turns,
            current_cooldown=self.cooldown_turns,
            ability_type=self.ability_type,
            damage_multiplier=self.damage_multiplier,
            range=self.range
        )
    
    def reduce_cooldown(self) -> 'Ability':
        """Reduce el cooldown en 1 turno"""
        new_cooldown = max(0, self.current_cooldown - 1)
        return Ability(
            id=self.id,
            name=self.name,
            description=self.description,
            ph_cost=self.ph_cost,
            cooldown_turns=self.cooldown_turns,
            current_cooldown=new_cooldown,
            ability_type=self.ability_type,
            damage_multiplier=self.damage_multiplier,
            range=self.range
        )
from dataclasses import dataclass
from uuid import UUID, uuid4

@dataclass(frozen=True)
class AbilityId:
    """Value Object para identificadores de habilidades"""
    value: UUID
    
    @classmethod
    def generate(cls) -> 'AbilityId':
        return AbilityId(uuid4())
    
    def __str__(self) -> str:
        return str(self.value)
# game/core/domain/entities/value_objects/damage.py
from dataclasses import dataclass

@dataclass(frozen=True)
class Damage:
    """Value Object SIMPLE para da√±o - SIN TIPOS COMPLEJOS"""
    amount: int
    
    def __post_init__(self):
        if self.amount < 0:
            raise ValueError("Damage amount cannot be negative")
    
    def __str__(self) -> str:
        return f"{self.amount} damage"
from dataclasses import dataclass
from uuid import UUID, uuid4

@dataclass(frozen=True)
class EntityId:
    """Value Object simple para IDs"""
    value: UUID
    
    @classmethod
    def generate(cls) -> 'EntityId':
        return EntityId(uuid4())
    
    def __str__(self) -> str:
        return str(self.value)
from enum import Enum, auto

class Team(Enum):
    """Equipos del juego"""
    PLAYER = "player"
    ENEMY = "enemy"
    
    def __str__(self):
        return self.value

class GameState(Enum):
    """Estados del juego"""
    IDLE = auto()
    ENTITY_SELECTED = auto() 
    TRACING_ROUTE = auto()
    TARGETING_ABILITY = auto()
    AWAITING_CONFIRMATION = auto()

class CharacterClass(Enum):
    """Clases de personajes"""
    DAMAGE = "Da√±o"
    TACTICAL = "T√°ctico" 
    SUPPORT = "Apoyo"
    
    def __str__(self):
        return self.value

class ActionType(Enum):
    """Tipos de acciones"""
    MOVE = "move"
    BASIC_ATTACK = "basic_attack"
    ABILITY_ALPHA = "ability_alpha"
    ABILITY_BETA = "ability_beta" 
    ABILITY_ULTIMATE = "ability_ultimate"
    
    def __str__(self):
        return self.value
from dataclasses import dataclass
from typing import Any, List

@dataclass(frozen=True)
class Position:
    """Value Object - INMUTABLE para posiciones en grid"""
    x: int
    y: int
    
    def __post_init__(self):
        if not isinstance(self.x, int) or not isinstance(self.y, int):
            raise ValueError("Position coordinates must be integers")
    
    # ‚úÖ AGREGAR ESTOS M√âTODOS PARA HACER POSITION COMPARABLE
    def __lt__(self, other: Any) -> bool:
        """Permite comparar Position para ordenamiento (necesario para A*)"""
        if not isinstance(other, Position):
            return NotImplemented
        # Ordenar primero por x, luego por y
        return (self.x, self.y) < (other.x, other.y)
    
    def __le__(self, other: Any) -> bool:
        if not isinstance(other, Position):
            return NotImplemented
        return (self.x, self.y) <= (other.x, other.y)
    
    def __gt__(self, other: Any) -> bool:
        if not isinstance(other, Position):
            return NotImplemented
        return (self.x, self.y) > (other.x, other.y)
    
    def __ge__(self, other: Any) -> bool:
        if not isinstance(other, Position):
            return NotImplemented
        return (self.x, self.y) >= (other.x, other.y)
    
    # Los m√©todos existentes...
    def distance_to(self, other: 'Position') -> int:
        """Distancia Manhattan para movimiento t√°ctico"""
        return abs(self.x - other.x) + abs(self.y - other.y)
    
    def adjacent_positions(self) -> List['Position']:
        """Posiciones adyacentes (para movimiento y ataques)"""
        return [
            Position(self.x + 1, self.y),
            Position(self.x - 1, self.y), 
            Position(self.x, self.y + 1),
            Position(self.x, self.y - 1)
        ]
    
    def is_within_grid(self, grid_size: tuple) -> bool:
        """Verifica si la posici√≥n est√° dentro del grid"""
        return (0 <= self.x < grid_size[0] and 
                0 <= self.y < grid_size[1])
    
    @staticmethod
    def line_between(start: 'Position', end: 'Position') -> List['Position']:
        """Genera posiciones en l√≠nea recta entre dos puntos (simplificado)"""
        positions = []
        current = start
        
        while current != end:
            if current.x < end.x:
                current = Position(current.x + 1, current.y)
            elif current.x > end.x:
                current = Position(current.x - 1, current.y)
            elif current.y < end.y:
                current = Position(current.x, current.y + 1)
            elif current.y > end.y:
                current = Position(current.x, current.y - 1)
            positions.append(current)
            
        return positions
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Position):
            return False
        return self.x == other.x and self.y == other.y
    
    def __hash__(self) -> int:
        return hash((self.x, self.y))
    
    def __str__(self) -> str:
        return f"({self.x}, {self.y})"
from dataclasses import dataclass, field
from typing import Dict

@dataclass(frozen=True)
class Progression:
    """Value Object para la progresi√≥n temporal de FRACTALS (se reinicia cada sesi√≥n)"""
    level: int = 1
    experience: int = 0
    temporary_bonuses: Dict[str, int] = field(default_factory=dict)

    def add_experience(self, amount: int) -> 'Progression':
        new_experience = self.experience + amount
        new_level = self.level
        # L√≥gica simple de nivelaci√≥n: cada 100 puntos de experiencia sube de nivel
        if new_experience >= new_level * 100:
            new_level += 1
            new_experience = 0  # Reiniciamos la experiencia al subir de nivel
        return Progression(level=new_level, experience=new_experience, temporary_bonuses=self.temporary_bonuses.copy())

    def add_temporary_bonus(self, stat: str, value: int) -> 'Progression':
        new_bonuses = self.temporary_bonuses.copy()
        new_bonuses[stat] = new_bonuses.get(stat, 0) + value
        return Progression(level=self.level, experience=self.experience, temporary_bonuses=new_bonuses)
from dataclasses import dataclass
from typing import Any

@dataclass(frozen=True)
class EntityStats:
    """Value Object - INMUTABLE para estad√≠sticas de entidades"""
    max_hp: int
    current_hp: int
    max_ph: int  
    current_ph: int
    attack: int
    defense: int
    speed: int
    
    def __post_init__(self):
        # Validaciones de integridad
        if any(valor < 0 for valor in [self.max_hp, self.current_hp, self.max_ph, 
                                      self.current_ph, self.attack, self.defense, self.speed]):
            raise ValueError("Stats cannot be negative")
        
        if self.current_hp > self.max_hp:
            raise ValueError("Current HP cannot exceed Max HP")
            
        if self.current_ph > self.max_ph:
            raise ValueError("Current PH cannot exceed Max PH")
    
    def reduce_hp(self, amount: int) -> 'EntityStats':
        """Devuelve NUEVO objeto con HP reducido - INMUTABLE"""
        new_hp = max(0, self.current_hp - amount)
        return EntityStats(
            max_hp=self.max_hp,
            current_hp=new_hp,
            max_ph=self.max_ph,
            current_ph=self.current_ph,
            attack=self.attack,
            defense=self.defense,
            speed=self.speed
        )
    
    def reduce_ph(self, amount: int) -> 'EntityStats':
        """Devuelve NUEVO objeto con PH reducido - INMUTABLE"""
        new_ph = max(0, self.current_ph - amount)
        return EntityStats(
            max_hp=self.max_hp,
            current_hp=self.current_hp,
            max_ph=self.max_ph,
            current_ph=new_ph,
            attack=self.attack,
            defense=self.defense,
            speed=self.speed
        )
    
    def is_alive(self) -> bool:
        return self.current_hp > 0
    
    def hp_percentage(self) -> float:
        return (self.current_hp / self.max_hp) * 100 if self.max_hp > 0 else 0
from dataclasses import dataclass
from ..entities.value_objects.entity_id import EntityId
from ..entities.value_objects.ability_id import AbilityId

@dataclass(frozen=True)
class AbilityUsed:
    """Evento cuando se usa una habilidad"""
    caster_id: EntityId
    ability_id: AbilityId
    target_id: EntityId = None
    damage_dealt: int = 0
    healing_done: int = 0
from dataclasses import dataclass
from ..entities.value_objects.entity_id import EntityId

@dataclass(frozen=True)
class DashExecuted:
    dasher_id: EntityId
    target_id: EntityId
    damage: int
class DomainEvent:
    """Clase base m√≠nima para eventos - sin dataclass"""
    pass
from dataclasses import dataclass
from uuid import UUID
from .domain_event import DomainEvent

@dataclass(frozen=True)
class EnemyTurnEnded(DomainEvent):
    """Evento de dominio cuando termina el turno del enemigo"""
    battle_id: UUID
    turn_count: int
from dataclasses import dataclass
from uuid import UUID
from .domain_event import DomainEvent

@dataclass(frozen=True)
class EnemyTurnStarted(DomainEvent):
    """Evento de dominio cuando comienza el turno del enemigo"""
    battle_id: UUID
    turn_count: int
from dataclasses import dataclass
from ..entities.value_objects.entity_id import EntityId

@dataclass(frozen=True)
class EntityDamaged:
    entity_id: EntityId
    old_hp: int
    new_hp: int
    damage_amount: int
from dataclasses import dataclass
from ..entities.value_objects.entity_id import EntityId

@dataclass(frozen=True)
class EntityDied:
    entity_id: EntityId
from dataclasses import dataclass
from ..entities.value_objects.entity_id import EntityId

@dataclass(frozen=True)
class EntityHealed:
    """Evento cuando una entidad es curada"""
    entity_id: EntityId
    heal_amount: int
    healer_id: EntityId = None
from dataclasses import dataclass
from ..entities.value_objects.entity_id import EntityId

@dataclass(frozen=True)
class EntityLeveledUp:
    entity_id: EntityId
    old_level: int
    new_level: int
from dataclasses import dataclass
from uuid import UUID
from .domain_event import DomainEvent

@dataclass(frozen=True)
class PlayerTurnEnded(DomainEvent):
    """Evento de dominio cuando termina el turno del jugador"""
    battle_id: UUID
    turn_count: int
from dataclasses import dataclass
from uuid import UUID
from .domain_event import DomainEvent

@dataclass(frozen=True)
class PlayerTurnStarted(DomainEvent):
    """Evento de dominio cuando comienza el turno del jugador"""
    battle_id: UUID
    turn_count: int
from dataclasses import dataclass
from uuid import UUID

@dataclass(frozen=True)
class TurnEnded:
    battle_id: UUID
    turn_count: int
# Battle Repository Interface
from abc import ABC, abstractmethod
from typing import List, Optional
from uuid import UUID
from ..entities.aggregates.battle import Battle

class BattleRepository(ABC):
    """Interface para el repositorio de battles - AGREGADO RAIZ"""
    
    @abstractmethod
    def get_by_id(self, battle_id: UUID) -> Battle:
        pass
    
    @abstractmethod
    def save(self, battle: Battle) -> None:
        pass
    
    @abstractmethod
    def delete(self, battle_id: UUID) -> None:
        pass
    
    @abstractmethod
    def get_all(self) -> List[Battle]:
        pass
# Entity Repository Interface
# Unit of Work Interface
# Ability Execution Service
from ..entities.battle_entity import BattleEntity
from ..entities.value_objects.position import Position

class CoverSystem:
    """Sistema de cobertura SIMPLE para FRACTALS - CON L√çMITES DEL GRID"""
    
    @staticmethod
    def has_cover(entity: BattleEntity, obstacles: set, grid_size: tuple = (8, 8)) -> bool:
        """Verifica si una entidad tiene cobertura, considerando l√≠mites del grid"""
        for adjacent_pos in entity.position.adjacent_positions():
            # Verificar que la posici√≥n adyacente est√© dentro del grid
            if (0 <= adjacent_pos.x < grid_size[0] and 
                0 <= adjacent_pos.y < grid_size[1] and
                adjacent_pos in obstacles):
                return True
        return False
    
    @staticmethod
    def get_cover_defense_bonus() -> int:
        """Bonus de defensa por tener cobertura"""
        return 20  # +20 defensa simple
from ..config.game_config import GAME_CONFIG

class DamageCalculationService:
    """Servicio centralizado para c√°lculos de da√±o"""
    
    @staticmethod
    def calculate_basic_attack_damage(attacker, defender) -> int:
        """Calcula da√±o usando stats reales en lugar de hardcode"""
        base_damage = max(1, attacker.stats.attack - (defender.stats.defense // 2))
        return base_damage
    
    @staticmethod
    def calculate_ability_damage(attacker, defender, multiplier: float) -> int:
        """Calcula da√±o de habilidad"""
        damage = int(attacker.stats.attack * multiplier) - (defender.stats.defense // 2)
        return max(1, damage)
    
    @staticmethod
    def calculate_dash_damage() -> int:
        """Da√±o de embestida desde configuraci√≥n"""
        return GAME_CONFIG.BASE_DASH_DAMAGE
# Effect Application Service
from ..entities.battle_entity import BattleEntity

class ExperienceService:
    """Servicio para gestionar experiencia y progresi√≥n temporal"""
    
    @staticmethod
    def calculate_experience_reward(enemy_level: int, player_level: int) -> int:
        """Calcula experiencia basada en diferencia de niveles"""
        base_exp = 50
        level_diff = enemy_level - player_level
        
        if level_diff > 0:
            return base_exp + (level_diff * 10)  # Bonus por enemigo m√°s fuerte
        else:
            return max(10, base_exp + (level_diff * 5))  # Reducci√≥n por enemigo m√°s d√©bil
    
    @staticmethod
    def apply_level_up_benefits(entity: BattleEntity) -> None:
        """Aplica beneficios al subir de nivel (simple)"""
        # Por ahora, solo aumentamos stats b√°sicos
        # En el futuro podr√≠a ser m√°s complejo
        old_stats = entity.stats
        # Aqu√≠ ir√≠a la l√≥gica para mejorar stats
        # Por simplicidad, no implementamos cambios a√∫n
        pass
from typing import List, Set
from ..entities.battle_entity import BattleEntity
from ..entities.value_objects.position import Position
from ..entities.value_objects.entity_id import EntityId

class MovementService:
    """Servicio de dominio para movimiento y embestidas en FRACTALS"""

    @staticmethod
    def calculate_dash_damage(entity: BattleEntity) -> int:
        return max(1, int(entity.stats.attack * 0.1))  # 10% del ataque

    @staticmethod
    def validate_dash_target(dasher: BattleEntity, target: BattleEntity) -> bool:
        # Verificar que el objetivo no haya sido embestido en este movimiento
        return target.id not in dasher.dash_targets_this_move

    @staticmethod
    def get_adjacent_positions(position: Position) -> List[Position]:
        return position.adjacent_positions()

    @staticmethod
    def calculate_path(start: Position, end: Position, obstacles: Set[Position]) -> List[Position]:
        # Implementaci√≥n simple de camino (podr√≠a ser A* en el futuro)
        # Por ahora, devolvemos una l√≠nea recta (sin obst√°culos)
        path = []
        current = start
        while current != end:
            # Movimiento en una direcci√≥n a la vez
            if current.x < end.x:
                current = Position(current.x + 1, current.y)
            elif current.x > end.x:
                current = Position(current.x - 1, current.y)
            elif current.y < end.y:
                current = Position(current.x, current.y + 1)
            elif current.y > end.y:
                current = Position(current.x, current.y - 1)
            path.append(current)
            # Si encontramos un obst√°culo, rompemos (por simplicidad)
            if current in obstacles:
                break
        return path
from typing import Set, List
from ..entities.battle_entity import BattleEntity
from ..entities.value_objects.position import Position
from ..entities.value_objects.game_enums import Team

class MovementValidationService:
    """Servicio para validar movimientos en FRACTALS"""
    
    @staticmethod
    def validate_movement_path(start: Position, end: Position, obstacles: Set[Position], entities: List[BattleEntity]) -> bool:
        """Valida movimiento usando enums"""
        for entity in entities:
            if entity.position == end and entity.team == Team.PLAYER:  # Solo aliados bloquean
                return False
        if end in obstacles:
            return False
        return True
    
    @staticmethod
    def get_valid_movement_positions(entity: BattleEntity, movement_range: int, obstacles: Set[Position], all_entities: List[BattleEntity]) -> Set[Position]:
        """Obtiene posiciones v√°lidas para movimiento (simplificado)"""
        valid_positions = set()
        start = entity.position
        
        # Simple generaci√≥n de posiciones en un cuadrado
        for dx in range(-movement_range, movement_range + 1):
            for dy in range(-movement_range, movement_range + 1):
                if abs(dx) + abs(dy) <= movement_range:  # Distancia Manhattan
                    new_pos = Position(start.x + dx, start.y + dy)
                    
                    # Validar posici√≥n
                    if MovementValidationService.validate_movement_path(start, new_pos, obstacles, all_entities):
                        valid_positions.add(new_pos)
        
        return valid_positions
from typing import List, Set, Dict, Optional, Tuple
import heapq
from ..entities.value_objects.position import Position
from ..entities.battle_entity import BattleEntity

class PathfindingService:
    """Implementa A* para rutas din√°micas que evitan obst√°culos autom√°ticamente"""
    
    @staticmethod
    def find_path(start: Position, end: Position, 
                obstacles: Set[Position], 
                entities: List[BattleEntity],
                moving_entity: BattleEntity,
                is_preview: bool = False) -> List[Position]:  # ‚úÖ NUEVO par√°metro
        """
        Encuentra la ruta √≥ptima - ahora soporta modo previsualizaci√≥n
        """
        # ‚úÖ ACTUALIZADO: Usar is_preview en la validaci√≥n
        if not PathfindingService._is_position_available(end, obstacles, entities, moving_entity, is_preview):
            return []
        
        # Estructuras para A*
        open_set = []
        came_from: Dict[Position, Optional[Position]] = {}
        g_score: Dict[Position, float] = {start: 0}
        f_score: Dict[Position, float] = {start: PathfindingService._heuristic(start, end)}
        
        heapq.heappush(open_set, (f_score[start], start))
        
        while open_set:
            current_f, current = heapq.heappop(open_set)
            
            # Si llegamos al destino, reconstruir ruta
            if current == end:
                return PathfindingService._reconstruct_path(came_from, current)
            
            # Si excedemos la distancia m√°xima, abandonar
            if g_score[current] >= 999:  # MAX_MOVEMENT_RANGE
                continue
            
            # ‚úÖ ACTUALIZADO: Pasar is_preview a _get_neighbors
            for neighbor in PathfindingService._get_neighbors(current, obstacles, entities, moving_entity, is_preview):
                tentative_g = g_score[current] + 1
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + PathfindingService._heuristic(neighbor, end)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        return []  # No se encontr√≥ camino

    @staticmethod
    def _heuristic(a: Position, b: Position) -> int:
        """Distancia Manhattan para grid t√°ctico"""
        return abs(a.x - b.x) + abs(a.y - b.y)

    @staticmethod
    def _get_neighbors(pos: Position, 
                      obstacles: Set[Position],
                      entities: List[BattleEntity],
                      moving_entity: BattleEntity,
                      is_preview: bool = False) -> List[Position]:  # ‚úÖ NUEVO par√°metro
        """Obtiene posiciones vecinas v√°lidas"""
        neighbors = []
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # Solo horizontales/verticales
        
        for dx, dy in directions:
            new_pos = Position(pos.x + dx, pos.y + dy)
            # ‚úÖ ACTUALIZADO: Pasar is_preview
            if PathfindingService._is_position_available(new_pos, obstacles, entities, moving_entity, is_preview):
                neighbors.append(new_pos)
        
        return neighbors

    @staticmethod
    def _is_position_available(pos: Position, 
                              obstacles: Set[Position],
                              entities: List[BattleEntity],
                              moving_entity: BattleEntity,
                              is_preview: bool = False) -> bool:  # ‚úÖ NUEVO: modo previsualizaci√≥n
        """Verifica si una posici√≥n est√° disponible para previsualizaci√≥n o movimiento real"""
        # Verificar l√≠mites del grid
        from core.domain.config.game_config import GAME_CONFIG
        grid_width, grid_height = GAME_CONFIG.GRID_SIZE
        if not (0 <= pos.x < grid_width and 0 <= pos.y < grid_height):
            return False
        
        # Verificar obst√°culos (siempre bloquear)
        if pos in obstacles:
            return False
        
        # ‚úÖ MODIFICADO CR√çTICO: En modo previsualizaci√≥n, ignorar entidades
        if is_preview:
            # Solo bloquear si es un aliado (para no pisar a tus compa√±eros en la previsualizaci√≥n)
            for entity in entities:
                if entity.id == moving_entity.id:
                    continue
                if entity.position == pos and entity.team == moving_entity.team:  # Solo aliados bloquean
                    return False
            return True  # ‚úÖ PERMITIR posici√≥n aunque tenga enemigos
        
        # Para movimiento real: bloquear todas las entidades
        for entity in entities:
            if entity.id == moving_entity.id:
                continue
            if entity.position == pos and entity.stats.is_alive():
                return False
        
        return True

    @staticmethod
    def _reconstruct_path(came_from: Dict[Position, Position], 
                         current: Position) -> List[Position]:
        """Reconstruye la ruta desde el destino hasta el inicio"""
        path = [current]
        while current in came_from:
            current = came_from[current]
            path.append(current)
        path.reverse()
        return path[1:]
from typing import List, Set
from ..entities.value_objects.position import Position
from ..entities.battle_entity import BattleEntity
from ..entities.aggregates.battle import Battle
from .pathfinding_service import PathfindingService

class MovementRoute:
    """Value Object que representa una ruta completa con embestidas"""
    
    def __init__(self, path: List[Position], dash_targets: List[BattleEntity], is_valid: bool = True):
        self.path = path
        self.dash_targets = dash_targets
        self.is_valid = is_valid
        self.total_distance = len(path)
        self.dash_damage = len(dash_targets) * 15  # 15 da√±o fijo por embestida

class RouteSystem:
    """Sistema simplificado para rutas con puntos de anclaje"""

    @staticmethod
    def calculate_route_with_anchors(start: Position, destination: Position,
                                     anchors: List[Position], battle: Battle,
                                     moving_entity: BattleEntity) -> MovementRoute:
        """
        Calcula ruta que pasa por todos los puntos de anclaje en orden
        A ‚Üí Anchor1 ‚Üí Anchor2 ‚Üí ... ‚Üí Destination
        """
        all_points = [start] + anchors + [destination]
        full_path = []

        # Calcular ruta por segmentos
        for i in range(len(all_points) - 1):
            segment_start = all_points[i]
            segment_end = all_points[i + 1]

            # ‚úÖ ACTUALIZADO CR√çTICO: Usar is_preview=True para previsualizaci√≥n
            segment = PathfindingService.find_path(
                segment_start, segment_end,
                battle.get_obstacles(),
                battle.get_entities(),
                moving_entity,
                is_preview=True  # ‚úÖ MODO PREVISUALIZACI√ìN - ignora enemigos
            )

            if not segment:
                return MovementRoute([], [], False)

            # A√±adir segmento a la ruta completa
            if full_path:
                full_path.extend(segment[1:])
            else:
                full_path.extend(segment)

        # Encontrar entidades en las posiciones de anclaje
        dash_targets = []
        for anchor_pos in anchors:
            enemy = battle.get_entity_at_position(anchor_pos)
            if enemy and enemy.team != moving_entity.team:
                dash_targets.append(enemy)

        return MovementRoute(full_path, dash_targets, True)
"""
SERVICIO DE TURNOS - En la ubicaci√≥n REAL
"""
from typing import List
from ..entities.value_objects.position import Position
from ..entities.value_objects.entity_id import EntityId
from ..entities.value_objects.game_enums import Team
from .route_system import RouteSystem, MovementRoute
from ..entities.aggregates.battle import Battle

class TurnService:
    """Maneja la l√≥gica de turnos"""
    
    def __init__(self, battle_repository):
        self.battle_repo = battle_repository
    
    def end_player_turn(self, battle_id) -> List:
        """Termina el turno del jugador"""
        battle = self.battle_repo.get_by_id(battle_id)
        
        if battle.current_turn != Team.PLAYER:
            raise ValueError("No es el turno del jugador")
        
        events = []
        actions_consumed = 0
        max_actions = battle.actions_remaining
        
        while battle.actions_remaining > 0 and actions_consumed < max_actions:
            turn_events = battle.consume_player_action()
            events.extend(turn_events)
            actions_consumed += 1
        
        self.battle_repo.save(battle)
        return events
    
    def move_entity(self, battle_id, entity_id, target_position: Position) -> str:
        """Mueve una entidad usando enums"""
        battle = self.battle_repo.get_by_id(battle_id)
        entity = battle.get_entity(entity_id)
        if not entity:
            raise ValueError("Entidad no encontrada")
        # ‚úÖ ACTUALIZADO: Usar Team enum
        if entity.team != Team.PLAYER:
            raise ValueError("Solo puedes mover entidades del jugador")
        if battle.current_turn != Team.PLAYER:
            raise ValueError("No es el turno del jugador")
        if entity.has_moved:
            raise ValueError("Esta entidad ya se movi√≥ este turno")
        # Validar movimiento
        if not battle.is_position_valid(target_position):
            raise ValueError("Posici√≥n fuera del grid")
        if battle.is_position_occupied(target_position):
            raise ValueError("Posici√≥n ocupada")
        if battle.is_obstacle(target_position):
            raise ValueError("Hay un obst√°culo en esa posici√≥n")
        # Ejecutar movimiento
        entity.move_to(target_position)
        battle.consume_player_action()
        self.battle_repo.save(battle)
        return f"{entity.name} movido a {target_position}"
    
    def get_valid_moves(self, battle_id, entity_id) -> List[Position]:
        """Obtiene movimientos v√°lidos para una entidad"""
        battle = self.battle_repo.get_by_id(battle_id)
        entity = battle.get_entity(entity_id)
        
        if not entity or entity.team != Team.PLAYER:
            return []
        
        valid_positions = []
        movement_range = 3
        
        for dx in range(-movement_range, movement_range + 1):
            for dy in range(-movement_range, movement_range + 1):
                if abs(dx) + abs(dy) <= movement_range:
                    new_pos = Position(entity.position.x + dx, entity.position.y + dy)
                    
                    if (battle.is_position_valid(new_pos) and
                        not battle.is_position_occupied(new_pos) and
                        not battle.is_obstacle(new_pos)):
                        valid_positions.append(new_pos)
        
        return valid_positions
    
    def calculate_movement_route(self, battle_id, entity_id, target_position: Position) -> MovementRoute:
        """Calcula y retorna una ruta sin ejecutarla (para previsualizaci√≥n)"""
        battle = self.battle_repo.get_by_id(battle_id)
        entity = battle.get_entity(entity_id)
        
        if not entity:
            raise ValueError("Entidad no encontrada")
            
        return RouteSystem.calculate_route(entity.position, target_position, battle, entity)
    
    def execute_movement_with_dashes(self, battle_id, entity_id, target_position: Position, 
                                   marked_dash_targets: List[EntityId] = None) -> str:
        """Ejecuta movimiento con validaciones usando enums"""
        if marked_dash_targets is None:
            marked_dash_targets = []
        battle = self.battle_repo.get_by_id(battle_id)
        entity = battle.get_entity(entity_id)
        # ‚úÖ ACTUALIZADO: Usar Team enum
        if not entity or entity.team != Team.PLAYER or battle.current_turn != Team.PLAYER or entity.has_moved:
            raise ValueError("Movimiento no v√°lido")
        # Calcular ruta
        route = RouteSystem.calculate_route(entity.position, target_position, battle, entity)
        if not route.path:
            raise ValueError("No hay ruta v√°lida hacia la posici√≥n objetivo")
        if not route.is_valid:
            raise ValueError("La ruta excede el l√≠mite de velocidad")
        # FILTRAR embestidas: solo las marcadas manualmente + m√°ximo 1 por enemigo
        valid_dash_targets = []
        dash_target_ids = set()
        for enemy in route.dash_targets:
            # Solo incluir si fue marcado manualmente Y no ha sido embestido a√∫n
            if (enemy.id in marked_dash_targets and 
                enemy.id not in dash_target_ids and
                enemy.id not in entity.dash_targets_this_move):
                valid_dash_targets.append(enemy)
                dash_target_ids.add(enemy.id)
        # Ejecutar movimiento
        entity.move_to(target_position)
        # Ejecutar embestidas MANUALES filtradas
        dash_results = []
        for enemy in valid_dash_targets:
            try:
                events = entity.execute_dash_attack(enemy)
                dash_results.append({
                    "enemy": enemy.name,
                    "damage": 15,  # Da√±o fijo seg√∫n GDD
                    "success": True
                })
            except Exception as e:
                dash_results.append({
                    "enemy": enemy.name, 
                    "error": str(e),
                    "success": False
                })
        # Consumir acci√≥n de movimiento
        battle.consume_player_action()
        self.battle_repo.save(battle)
        # Construir mensaje de resultado
        if dash_results:
            successful_dashes = [r for r in dash_results if r["success"]]
            if successful_dashes:
                enemies_list = ", ".join([r["enemy"] for r in successful_dashes])
                return f"{entity.name} se movi√≥ a {target_position} y embisti√≥ a: {enemies_list}"
            else:
                return f"{entity.name} se movi√≥ a {target_position} (embestidas fallidas)"
        else:
            return f"{entity.name} se movi√≥ a {target_position}"
        
    def execute_ability(self, battle_id, caster_id, ability_type: str, 
                       target_entity_id: EntityId = None) -> str:
        """Ejecuta una habilidad con validaci√≥n de PH y TdE"""
        battle = self.battle_repo.get_by_id(battle_id)
        caster = battle.get_entity(caster_id)
        target_entity = battle.get_entity(target_entity_id) if target_entity_id else None

        if not caster:
            raise ValueError("Entidad no encontrada")

        # Validaciones b√°sicas
        if battle.current_turn != Team.PLAYER:
            raise ValueError("No es el turno del jugador")

        if caster.team != Team.PLAYER:
            raise ValueError("Solo puedes usar habilidades con entidades del jugador")

        # Ejecutar habilidad
        try:
            events = caster.use_ability(ability_type, target_entity)
            
            # Consumir acci√≥n del turno
            battle.consume_player_action()
            self.battle_repo.save(battle)
            
            # Construir mensaje
            ability = caster.abilities[ability_type]
            if target_entity:
                if ability.damage_multiplier > 0:
                    return f"{caster.name} usa {ability.name} en {target_entity.name}"
                else:
                    return f"{caster.name} usa {ability.name} en {target_entity.name}"
            else:
                return f"{caster.name} usa {ability.name}"
                
        except Exception as e:
            raise ValueError(f"Error al usar habilidad: {e}")

    def get_ability_targets(self, battle_id, caster_id, ability_type: str) -> List[EntityId]:
        """Obtiene objetivos v√°lidos para una habilidad"""
        battle = self.battle_repo.get_by_id(battle_id)
        caster = battle.get_entity(caster_id)
        
        if not caster or ability_type not in caster.abilities:
            return []
            
        ability = caster.abilities[ability_type]
        targets = []
        
        # L√≥gica simple de rango
        for entity in battle._entities.values():
            if entity.id == caster.id:
                continue
                
            distance = caster.position.distance_to(entity.position)
            if distance <= ability.range:
                # Validar tipo de objetivo seg√∫n la habilidad
                if ability.damage_multiplier > 0:  # Habilidad de da√±o
                    if entity.team != caster.team:
                        targets.append(entity.id)
                else:  # Habilidad de curaci√≥n/soporte
                    if entity.team == caster.team:
                        targets.append(entity.id)
        
        return targets

    def calculate_route_with_anchors(self, battle_id, entity_id, destination: Position, anchors: List[Position]) -> MovementRoute:
        """Calcula ruta que pasa por puntos de anclaje"""
        battle = self.battle_repo.get_by_id(battle_id)
        entity = battle.get_entity(entity_id)
        start_pos = entity.position
        return RouteSystem.calculate_route_with_anchors(
            start_pos, destination, anchors, battle, entity
        )

    def execute_movement_with_dash_anchors(self, battle_id, entity_id, final_destination: Position,
                                         anchors: List[Position]) -> str:
        """Ejecuta movimiento pasando por puntos de anclaje para embestidas"""
        battle = self.battle_repo.get_by_id(battle_id)
        entity = battle.get_entity(entity_id)
        # Validaciones b√°sicas
        if not entity or entity.team != Team.PLAYER or battle.current_turn != Team.PLAYER or entity.has_moved:
            raise ValueError("Movimiento no v√°lido")
        # Calcular ruta final (movimiento REAL, is_preview=False)
        from .route_system import RouteSystem
        start_pos = entity.position
        route = RouteSystem.calculate_route_with_anchors(
            start_pos, final_destination, anchors, battle, entity  # is_preview=False por defecto
        )
        if not route.is_valid or not route.path:
            raise ValueError("No hay ruta v√°lida")
        # Mover entidad a la posici√≥n final
        entity.move_to(final_destination)
        # Ejecutar embestidas en los puntos de anclaje
        dash_results = []
        for enemy in route.dash_targets:
            try:
                events = entity.execute_dash_attack(enemy)
                dash_results.append({
                    "enemy": enemy.name,
                    "success": True
                })
            except Exception as e:
                dash_results.append({
                    "enemy": enemy.name,
                    "error": str(e),
                    "success": False
                })
        # Consumir acci√≥n
        battle.consume_player_action()
        self.battle_repo.save(battle)
        # Mensaje de resultado
        successful_dashes = [r for r in dash_results if r["success"]]
        if successful_dashes:
            enemies_list = ", ".join([r["enemy"] for r in successful_dashes])
            return f"{entity.name} se movi√≥ y embisti√≥ a: {enemies_list}"
        else:
            return f"{entity.name} se movi√≥ a {final_destination}"
# core/domain/services/__init__.py - ACTUALIZAR
from .turn_service import TurnService
from .pathfinding_service import PathfindingService
from .route_system import RouteSystem, MovementRoute

__all__ = [
    "TurnService", 
    "PathfindingService", 
    "RouteSystem", 
    "MovementRoute"
]
# Ability Config Mapper
# JSON Config Loader
from typing import List
from ...core.application.ports.event_publisher_port import EventPublisherPort
from ...core.domain.events.domain_event import DomainEvent

class DomainEventPublisher(EventPublisherPort):
    """Implementaci√≥n simple de publicador de eventos"""
    
    def __init__(self):
        self._subscribers = []
    
    def publish(self, event: DomainEvent) -> None:
        """Publica un evento a todos los suscriptores"""
        for subscriber in self._subscribers:
            subscriber(event)
    
    def publish_all(self, events: List[DomainEvent]) -> None:
        """Publica m√∫ltiples eventos"""
        for event in events:
            self.publish(event)
    
    def subscribe(self, subscriber) -> None:
        """Suscribe un callback para recibir eventos"""
        self._subscribers.append(subscriber)
# Event Bus
from typing import Dict, List, Optional
from uuid import UUID
from core.domain.repositories.battle_repository import BattleRepository
from core.domain.entities.aggregates.battle import Battle

class InMemoryBattleRepository(BattleRepository):
    """Repositorio en memoria para battles - CON IMPORTS CORREGIDOS"""
    
    def __init__(self):
        self._battles: Dict[UUID, Battle] = {}
    
    def get_by_id(self, battle_id: UUID) -> Battle:
        battle = self._battles.get(battle_id)
        if not battle:
            raise ValueError(f"Battle {battle_id} no encontrada")
        return battle
    
    def save(self, battle: Battle) -> None:
        self._battles[battle.id] = battle
    
    def delete(self, battle_id: UUID) -> None:
        if battle_id in self._battles:
            del self._battles[battle_id]
    
    def get_all(self) -> List[Battle]:
        return list(self._battles.values())
from typing import Dict, List, Optional
from characters.domain.repositories.character_repository import CharacterRepository
from characters.domain.entities.character import Character

class InMemoryCharacterRepository(CharacterRepository):
    """Repositorio en memoria para characters"""
    
    def __init__(self):
        self._characters: Dict[str, Character] = {}
    
    def get_by_id(self, character_id: str) -> Optional[Character]:
        return self._characters.get(character_id)
    
    def save(self, character: Character) -> None:
        self._characters[character.id] = character
    
    def get_all(self) -> List[Character]:
        return list(self._characters.values())
    
    def get_by_class(self, character_class: str) -> List[Character]:
        return [char for char in self._characters.values() 
                if char.character_class == character_class]
# SQLite Battle Repository
# In Memory Unit of Work
import pygame
from typing import List, Callable, Optional
from core.domain.entities.battle_entity import BattleEntity

class ActionMenu:
    """Men√∫ flotante de acciones seg√∫n tu GDD"""
    
    def __init__(self, entity: BattleEntity, screen_position: tuple):
        self.entity = entity
        self.screen_position = screen_position
        self.visible = True
        self.buttons = []
        
        self.actions = self._build_available_actions()
    
    def _build_available_actions(self) -> List[dict]:
        """Construye lista de acciones con informaci√≥n de PH y cooldowns"""
        actions = [
            {
                "name": "Moverse", 
                "key": "M", 
                "type": "move",
                "enabled": self._can_move(),
                "description": "Trazar ruta y mover entidad",
                "ph_cost": 0,
                "cooldown": 0
            }
        ]
        
        # A√±adir habilidades desde el sistema de PH/TdE
        for ability_type, ability in self.entity.abilities.items():
            actions.append({
                "name": ability.name,
                "key": self._get_ability_key(ability_type),
                "type": ability_type,
                "enabled": self.entity.can_use_ability(ability_type),
                "description": ability.description,
                "ph_cost": ability.ph_cost,
                "cooldown": ability.current_cooldown,
                "max_cooldown": ability.cooldown_turns
            })
        
        return actions
    
    def _get_ability_key(self, ability_type: str) -> str:
        """Mapea tipos de habilidad a teclas"""
        key_map = {
            "basic_attack": "A",
            "ability_alpha": "1", 
            "ability_beta": "2",
            "ability_ultimate": "3"
        }
        return key_map.get(ability_type, "?")
    
    def _can_move(self) -> bool:
        """Puede moverse si no lo ha hecho este turno"""
        return not self.entity.has_moved
    
    def _can_attack(self) -> bool:
        """Puede atacar si no ha usado ataque este turno"""
        return "basic_attack" not in self.entity.actions_used_this_turn
    
    def _can_use_ability(self, ability_type: str) -> bool:
        """Puede usar habilidad si tiene PH y no la ha usado este turno"""
        # Placeholder - luego integraremos PH y TdE
        return ability_type not in self.entity.actions_used_this_turn
    
    def handle_click(self, mouse_pos: tuple) -> Optional[str]:
        """Procesa click en el men√∫ y retorna el tipo de acci√≥n seleccionada"""
        for button in self.buttons:
            if button["rect"].collidepoint(mouse_pos):
                return button["action_type"]
        return None
    
    def draw(self, screen: pygame.Surface):
        """Renderiza el men√∫ con informaci√≥n de PH y TdE"""
        if not self.visible or not self.actions:
            return
        
        # Configuraci√≥n visual mejorada
        menu_width = 280  # M√°s ancho para mostrar PH/TdE
        item_height = 50  # M√°s alto para informaci√≥n adicional
        padding = 10
        menu_height = len(self.actions) * item_height + padding * 2
        
        x, y = self.screen_position
        
        # Ajustar posici√≥n
        if x + menu_width > screen.get_width():
            x = screen.get_width() - menu_width - 10
        if y + menu_height > screen.get_height():
            y = screen.get_height() - menu_height - 10
        
        # Fondo del men√∫
        menu_rect = pygame.Rect(x, y, menu_width, menu_height)
        pygame.draw.rect(screen, (40, 40, 60), menu_rect)
        pygame.draw.rect(screen, (100, 100, 150), menu_rect, 2)
        
        # Header con informaci√≥n de PH
        header_rect = pygame.Rect(x, y, menu_width, 30)
        pygame.draw.rect(screen, (60, 60, 80), header_rect)
        
        ph_font = pygame.font.Font(None, 20)
        ph_text = f"PH: {self.entity.current_ph}/{self.entity.max_ph}"
        ph_surface = ph_font.render(ph_text, True, (200, 200, 255))
        screen.blit(ph_surface, (x + 10, y + 8))
        
        # Renderizar cada acci√≥n
        self.buttons = []
        font = pygame.font.Font(None, 22)
        small_font = pygame.font.Font(None, 16)
        
        for i, action in enumerate(self.actions):
            button_y = y + 30 + i * item_height
            button_rect = pygame.Rect(
                x + padding, 
                button_y, 
                menu_width - padding * 2, 
                item_height - 5
            )
            
            self.buttons.append({
                "rect": button_rect,
                "action_type": action["type"]
            })
            
            # Color del bot√≥n basado en disponibilidad
            if action["enabled"]:
                color = (80, 120, 200)
                border_color = (120, 160, 220)
                text_color = (255, 255, 255)
            else:
                color = (60, 60, 80)
                border_color = (80, 80, 100)
                text_color = (150, 150, 150)
            
            pygame.draw.rect(screen, color, button_rect)
            pygame.draw.rect(screen, border_color, button_rect, 2)
            
            # Texto principal de la acci√≥n
            action_text = f"{action['name']} ({action['key']})"
            text_surface = font.render(action_text, True, text_color)
            screen.blit(text_surface, (button_rect.x + 10, button_rect.y + 5))
            
            # Informaci√≥n de PH y TdE
            info_text = f"Costo: {action['ph_cost']} PH"
            if action["cooldown"] > 0:
                info_text += f" | TdE: {action['cooldown']}"
            
            info_surface = small_font.render(info_text, True, (200, 200, 200))
            screen.blit(info_surface, (button_rect.x + 10, button_rect.y + 25))
            
            # Descripci√≥n (tooltip en hover podr√≠amos a√±adir despu√©s)
            desc_surface = small_font.render(action['description'], True, (180, 180, 180))
            screen.blit(desc_surface, (button_rect.x + 10, button_rect.y + 35))            

    def set_visibility(self, visible: bool):
        """Establece la visibilidad del men√∫"""
        self.visible = visible
import pygame
from typing import List, Optional
from core.domain.entities.value_objects.position import Position
from core.domain.services.route_system import MovementRoute
from .movement_visualizer import MovementVisualizer
from .rendering_service import RenderingService
from .action_menu import ActionMenu
from .game_states import GameState, GameContext

class EnhancedRenderingService(RenderingService):
    """Servicio de renderizado extendido con soporte para estados del juego"""

    def __init__(self, screen_width: int = 800, screen_height: int = 600):
        super().__init__(screen_width, screen_height)
        self.movement_visualizer = MovementVisualizer(
            self.grid_offset, self.cell_size, self.grid_size
        )
        self.current_route: Optional[MovementRoute] = None
        self.action_menu: Optional[ActionMenu] = None
        self.game_context: Optional[GameContext] = None

    def render_battle(self, battle, game_context: GameContext, valid_moves: List[Position] = None) -> None:
        """Renderiza la batalla considerando el estado actual del juego"""
        self.game_context = game_context
        self.screen.fill(self.colors["background"])
        
        # Renderizar elementos b√°sicos
        self._render_grid()
        self._render_valid_moves(valid_moves)
        
        for obstacle in battle._obstacles:
            self._render_obstacle(obstacle)
        
        # Renderizar entidades con marcado especial para embestidas
        for entity in battle._entities.values():
            is_selected = entity.id == game_context.selected_entity_id
            is_marked_for_dash = entity.position in getattr(game_context, 'dash_anchors', [])
            self._render_entity(entity, is_selected, is_marked_for_dash)
        
        # Renderizar ruta de movimiento si estamos en modo trazado
        if (game_context.current_state == GameState.TRACING_ROUTE and 
            game_context.current_route is not None):
            
            selected_entity = battle.get_entity(game_context.selected_entity_id)
            if selected_entity:
                self.movement_visualizer.render_route(
                    self.screen, 
                    game_context.current_route, 
                    selected_entity.position, 
                    is_dragging=False,
                    dash_anchors=getattr(game_context, 'dash_anchors', [])
                )
        
        # Renderizar men√∫ de acciones si hay entidad seleccionada
        if (game_context.current_state == GameState.ENTITY_SELECTED and 
            self.action_menu is not None):
            self.action_menu.draw(self.screen)
        
        # Renderizar informaci√≥n de estado actual
        self._render_state_info(game_context)
        
        self._render_ui(battle)
        
        pygame.display.flip()
        self.clock.tick(60)

    def _render_entity(self, entity, is_selected: bool = False, is_marked_for_dash: bool = False):
        """Renderiza una entidad con marcado especial para embestidas"""
        pos = entity.position
        team = entity.team

        screen_x = self.grid_offset[0] + pos.x * self.cell_size
        screen_y = self.grid_offset[1] + pos.y * self.cell_size

        # Color seg√∫n equipo
        if team == "player" or (hasattr(team, 'value') and team.value == "player"):
            color = (30, 144, 255)
        elif team == "enemy" or (hasattr(team, 'value') and team.value == "enemy"):
            color = self.colors["enemy"]
        else:
            color = self.colors["enemy"]

        # Dibujar entidad
        radius = self.cell_size // 3
        pygame.draw.circle(self.screen, color, (screen_x + self.cell_size//2, screen_y + self.cell_size//2), radius)
        
        # Resaltar si est√° seleccionada
        if is_selected:
            pygame.draw.circle(self.screen, self.colors["selected"], 
                             (screen_x + self.cell_size//2, screen_y + self.cell_size//2), 
                             radius + 4, 3)  # Borde amarillo m√°s grueso
        
        # Resaltar si est√° marcada para embestida
        if is_marked_for_dash:
            pygame.draw.circle(self.screen, (255, 50, 50),  # Rojo brillante
                             (screen_x + self.cell_size//2, screen_y + self.cell_size//2), 
                             radius + 8, 3)  # C√≠rculo rojo exterior
        
        # Barra de salud
        health_percent = entity.stats.current_hp / entity.stats.max_hp
        bar_width = self.cell_size - 10
        bar_height = 6
        
        # Fondo barra
        pygame.draw.rect(self.screen, (100, 100, 100), 
                        (screen_x + 5, screen_y - 10, bar_width, bar_height))
        # Salud actual
        pygame.draw.rect(self.screen, self.colors["health_bar"], 
                        (screen_x + 5, screen_y - 10, int(bar_width * health_percent), bar_height))
        
        # Nombre de la entidad
        name_surface = self.font.render(entity.name, True, self.colors["text"])
        name_rect = name_surface.get_rect(center=(screen_x + self.cell_size//2, screen_y - 25))
        self.screen.blit(name_surface, name_rect)

    def _render_state_info(self, game_context: GameContext):
        """Renderiza informaci√≥n del estado actual del juego"""
        state_info = {
            GameState.IDLE: "üí§ IDLE - Selecciona una entidad",
            GameState.ENTITY_SELECTED: "üìã ENTIDAD SELECCIONADA - Elige una acci√≥n",
            GameState.TRACING_ROUTE: "üõ£Ô∏è TRAZANDO RUTA - Mueve el cursor, click en enemigos para embestida",
            GameState.TARGETING_ABILITY: "üéØ SELECCIONANDO OBJETIVO - Click en objetivo",
            GameState.AWAITING_CONFIRMATION: "‚è≥ CONFIRMACI√ìN - Confirmando acci√≥n..."
        }
        
        state_text = state_info.get(game_context.current_state, "Estado desconocido")
        state_surface = self.font.render(state_text, True, (255, 255, 255))
        self.screen.blit(state_surface, (20, self.screen_height - 40))
        
        # Informaci√≥n adicional para modo trazado
        if (game_context.current_state == GameState.TRACING_ROUTE and 
            getattr(game_context, 'dash_anchors', [])):
            dash_info = f"Embestidas marcadas: {len(game_context.dash_anchors)}"
            dash_surface = self.font.render(dash_info, True, (255, 200, 200))
            self.screen.blit(dash_surface, (300, self.screen_height - 40))

    def update_route_preview(self, route: Optional[MovementRoute]) -> None:
        """Actualiza la ruta que se est√° previsualizando"""
        self.current_route = route

    def set_action_menu(self, action_menu: Optional[ActionMenu]) -> None:
        """Establece el men√∫ de acciones actual"""
        self.action_menu = action_menu
"""
GAME LOOP ACTUALIZADO - Sistema de embestidas como puntos de anclaje
"""
import pygame
from uuid import uuid4

from core.domain.entities.aggregates.battle import Battle
from core.domain.entities.battle_entity import BattleEntity
from core.domain.entities.value_objects.entity_id import EntityId
from core.domain.entities.value_objects.position import Position
from core.domain.entities.value_objects.stats import EntityStats
from core.domain.entities.value_objects.game_enums import Team, CharacterClass

from .input_service import InputService
from .enhanced_rendering_service import EnhancedRenderingService
from .game_states import GameState, GameContext
from .action_menu import ActionMenu
from typing import List

class GameLoop:
    def _handle_input_targeting_ability(self):
        pass
    """Coordina el flujo del juego con sistema de anclajes para embestidas"""
    
    def __init__(self, battle_repository, turn_service):
        self.battle_repo = battle_repository
        self.turn_service = turn_service
        self.input_service = InputService()
        self.renderer = EnhancedRenderingService()
        
        self.current_battle_id = None
        self.running = False
        
        # Contexto del juego con sistema de anclajes
        self.context = GameContext()
        self.action_menu = None
        self.valid_moves = []
        
        self.last_cursor_pos = None  # √öltima posici√≥n del cursor para trazado
        
        print("üéÆ Game Loop inicializado - Sistema de anclajes activo")
    
    def run(self):
        """Bucle principal con gesti√≥n de estados"""
        try:
            self._initialize()
            
            while self.running:
                self._process_input()
                self._update_game_state()
                self._render_frame()
                
        except Exception as e:
            print(f"üí• Error en game loop: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self.renderer.cleanup()
    
    def _initialize(self):
        """Inicializa el juego en estado IDLE"""
        self.renderer.initialize()
        self.current_battle_id = self._create_initial_battle()
        self.running = True
        self.context.reset()
        print("üöÄ Juego inicializado - Selecciona una entidad para comenzar")
        print("üéØ Nuevo sistema: Click en enemigos durante trazado para a√±adir puntos de embestida")
    
    def _process_input(self):
        """Procesa input seg√∫n el estado actual"""
        self.input_service.process_events()
        
        # Comandos globales (siempre disponibles)
        if self.input_service.is_key_pressed("QUIT") or self.input_service.is_key_pressed("ESCAPE"):
            self.running = False
        
        if self.input_service.is_key_pressed("RESET"):
            self._handle_reset_command()
        
        if self.input_service.is_key_pressed("SPACE"):
            self._handle_end_turn_command()
        
        # Manejo de input por estado
        state_handlers = {
            GameState.IDLE: self._handle_input_idle,
            GameState.ENTITY_SELECTED: self._handle_input_entity_selected,
            GameState.TRACING_ROUTE: self._handle_input_tracing_route,
            GameState.TARGETING_ABILITY: self._handle_input_targeting_ability,
        }
        
        handler = state_handlers.get(self.context.current_state)
        if handler:
            handler()
    
    def _handle_input_idle(self):
        """Estado IDLE: Click en entidades del jugador para seleccionar"""
        if self.input_service.is_mouse_clicked():
            battle = self.battle_repo.get_by_id(self.current_battle_id)
            grid_pos = self.input_service.get_mouse_grid_position(
                self.renderer.grid_offset, 
                self.renderer.cell_size, 
                self.renderer.grid_size
            )
            
            if not grid_pos:
                return
                
            target_pos = Position(grid_pos[0], grid_pos[1])
            cursor_pos = target_pos  # Definir cursor_pos correctamente
            clicked_entity = self._get_entity_at_position(battle, target_pos)

            # Validar que sea entidad del jugador y sea su turno
            if (clicked_entity and 
                clicked_entity.team == Team.PLAYER and 
                battle.current_turn == Team.PLAYER):
                self.last_cursor_pos = cursor_pos  # Actualizar √∫ltima posici√≥n del cursor

                self.context.selected_entity_id = clicked_entity.id
                self.context.current_state = GameState.ENTITY_SELECTED

                # Mostrar men√∫ de acciones
                screen_pos = self._position_to_screen(clicked_entity.position)
                self.action_menu = ActionMenu(clicked_entity, screen_pos)

                print(f"üéØ {clicked_entity.name} seleccionado")
                print("üìã Men√∫ de acciones disponible - Elige una acci√≥n")
    
    def _handle_input_entity_selected(self):
        """Estado ENTITY_SELECTED: Interactuar con men√∫ de acciones"""
        battle = self.battle_repo.get_by_id(self.current_battle_id)
        selected_entity = battle.get_entity(self.context.selected_entity_id)
        
        if not selected_entity:
            self._clear_selection()
            return
        
        # Click en el men√∫ de acciones
        if self.input_service.is_mouse_clicked():
            mouse_pos = self.input_service.get_mouse_position()
            selected_action = self.action_menu.handle_click(mouse_pos)
            
            if selected_action:
                self._handle_action_selection(selected_action, selected_entity)
            else:
                # Click fuera del men√∫ - deseleccionar
                self._clear_selection()
    
    def _handle_input_tracing_route(self):
        """Estado TRACING_ROUTE: Trazado de ruta con sistema de anclajes"""
        battle = self.battle_repo.get_by_id(self.current_battle_id)
        selected_entity = battle.get_entity(self.context.selected_entity_id)
        
        if not selected_entity:
            self._clear_selection()
            return
        
        # Obtener posici√≥n actual del cursor en el grid
        grid_pos = self.input_service.get_mouse_grid_position(
            self.renderer.grid_offset,
            self.renderer.cell_size, 
            self.renderer.grid_size
        )
        
        if grid_pos:
            cursor_pos = Position(grid_pos[0], grid_pos[1])
            self.last_cursor_pos = cursor_pos  # Actualizar √∫ltima posici√≥n del cursor
            
            # ACTUALIZAR RUTA EN TIEMPO REAL con anclajes actuales
            self._update_route_preview(selected_entity, cursor_pos, battle)
            
            # Click: marcar anclaje de embestida o confirmar movimiento
            if self.input_service.is_mouse_clicked():
                self._handle_route_click(battle, cursor_pos, selected_entity)
    
    def _handle_action_selection(self, action_type: str, entity: BattleEntity):
        """Procesa selecci√≥n de acci√≥n del men√∫"""
        battle = self.battle_repo.get_by_id(self.current_battle_id)
        
        if action_type == "move":
            # Entrar en modo trazado de ruta
            self.context.current_state = GameState.TRACING_ROUTE
            self.context.pending_action = "move"
            self.action_menu.set_visibility(False)
            
            # Limpiar movimientos v√°lidos para que no se muestre el rango azul
            self.valid_moves = []
            
            print("üõ£Ô∏è Modo TRAZADO DE RUTA activado")
            print("üí° Mueve el cursor para ver la ruta")
            print("üéØ Click en enemigos para a√±adir puntos de embestida")
            print("üí° Click en casilla vac√≠a para confirmar movimiento")
            
        elif action_type == "basic_attack":
            # Preparar ataque b√°sico
            self.context.current_state = GameState.TARGETING_ABILITY
            self.context.pending_action = "basic_attack"
            self.action_menu.set_visibility(False)
            
            print("üéØ Modo ATAQUE - Selecciona objetivo")
            
        elif action_type.startswith("ability_"):
            # Preparar habilidad
            self.context.current_state = GameState.TARGETING_ABILITY  
            self.context.pending_action = action_type
            self.action_menu.set_visibility(False)
            
            print(f"üîÆ Modo {action_type.upper()} - Selecciona objetivo")
    
    def _update_route_preview(self, entity: BattleEntity, destination: Position, battle: Battle):
        """Actualiza la previsualizaci√≥n de ruta con anclajes actuales"""
        
        try:
            # Calcular ruta que pasa por todos los anclajes
            route = self.turn_service.calculate_route_with_anchors(
                self.current_battle_id,
                self.context.selected_entity_id,
                destination,
                self.context.dash_anchors
            )
            # Si la ruta est√° vac√≠a pero el destino es v√°lido, mostrar al menos el punto actual
            if not route or not route.path:
                route = type(route)([entity.position], [], True)
            self.context.current_route = route
            self.renderer.update_route_preview(self.context.current_route)
        except Exception as e:
            print(f"‚ùå Error calculando ruta: {e}")
            self.context.current_route = None
            self.renderer.update_route_preview(None)
    
    def _handle_route_click(self, battle, click_pos: Position, selected_entity: BattleEntity):
        """Maneja clicks durante el trazado de ruta - SISTEMA DE ANCLAJES"""
        clicked_entity = self._get_entity_at_position(battle, click_pos)
        
        if clicked_entity and clicked_entity.team == Team.ENEMY:
            # MARCAR/DESMARCAR punto de anclaje para embestida
            enemy_pos = clicked_entity.position
            ruta_actualizada = False
            if enemy_pos in self.context.dash_anchors:
                # Desmarcar anclaje
                self.context.dash_anchors.remove(enemy_pos)
                print(f"‚ùå Embestida desmarcada: {clicked_entity.name}")
                ruta_actualizada = True
            else:
                # Marcar anclaje - verificar que no sea el mismo enemigo
                anchored_enemies = self._get_anchored_enemies(battle)
                if clicked_entity.id not in [e.id for e in anchored_enemies]:
                    self.context.dash_anchors.append(enemy_pos)
                    print(f"üéØ Embestida marcada: {clicked_entity.name} (Anclaje #{len(self.context.dash_anchors)})")
                    # Mostrar informaci√≥n de anclajes actuales
                    if len(self.context.dash_anchors) > 0:
                        print(f"üìå Anclajes activos: {len(self.context.dash_anchors)}")
                    ruta_actualizada = True
                else:
                    print(f"‚ö†Ô∏è Ya has marcado a {clicked_entity.name} para embestida")
            # Forzar actualizaci√≥n de la ruta para evitar que desaparezca
            if ruta_actualizada:
                self._update_route_preview(selected_entity, click_pos, battle)
            
        else:
            # CONFIRMAR movimiento final con anclajes
            try:
                message = self.turn_service.execute_movement_with_dash_anchors(
                    self.current_battle_id, 
                    self.context.selected_entity_id,
                    click_pos,
                    self.context.dash_anchors
                )
                print(f"‚û°Ô∏è {message}")
                self._clear_selection()
                
            except Exception as e:
                print(f"‚ùå Error en movimiento: {e}")
    
    def _get_anchored_enemies(self, battle) -> List[BattleEntity]:
        """Obtiene las entidades enemigas en las posiciones de anclaje"""
        anchored_enemies = []
        for anchor_pos in self.context.dash_anchors:
            enemy = battle.get_entity_at_position(anchor_pos)
            if enemy:
                anchored_enemies.append(enemy)
        return anchored_enemies
    
    def _clear_selection(self):
        """Limpia toda la selecci√≥n y vuelve al estado IDLE"""
        self.context.reset()
        self.action_menu = None
        self.valid_moves = []
        print("üßπ Selecci√≥n limpiada")
    
    def _update_game_state(self):
        """Actualiza estado del juego"""
        # Por ahora vac√≠o, la l√≥gica est√° en los servicios
        pass
    
    def _render_frame(self):
        """Renderiza el frame con rutas y anclajes"""
        battle = self.battle_repo.get_by_id(self.current_battle_id)
        
        # Pasar el contexto al renderizador
        self.renderer.set_action_menu(self.action_menu)
        self.renderer.render_battle(battle, self.context, self.valid_moves)
    
    def _create_initial_battle(self):
        """Crea batalla inicial usando enums"""
        battle_id = uuid4()
        battle = Battle(battle_id, mode="arcade", grid_size=(8, 8))
        
        # Crear jugador
        player = BattleEntity(
            entity_id=EntityId.generate(),
            position=Position(1, 1),
            stats=EntityStats(100, 100, 50, 50, 25, 15, 10),
            team=Team.PLAYER,
            name="Ricchard",
            character_class=CharacterClass.DAMAGE
        )
        
        # Crear enemigos
        enemy1 = BattleEntity(
            entity_id=EntityId.generate(),
            position=Position(6, 6),
            stats=EntityStats(80, 80, 30, 30, 20, 10, 8),
            team=Team.ENEMY,
            name="Enemy Bot 1",
            character_class=CharacterClass.DAMAGE
        )
        
        enemy2 = BattleEntity(
            entity_id=EntityId.generate(),
            position=Position(4, 4),
            stats=EntityStats(70, 70, 25, 25, 18, 8, 6),
            team=Team.ENEMY,
            name="Enemy Bot 2",
            character_class=CharacterClass.DAMAGE
        )
        
        # A√±adir obst√°culos desde configuraci√≥n
        from core.domain.config.game_config import GAME_CONFIG
        for obstacle_pos in GAME_CONFIG.INITIAL_OBSTACLES:
            battle.add_obstacle(Position(obstacle_pos[0], obstacle_pos[1]))
        
        battle.add_entity(player)
        battle.add_entity(enemy1)
        battle.add_entity(enemy2)
        
        self.battle_repo.save(battle)
        print(f"‚úîÔ∏è Batalla creada: {player.name} vs {enemy1.name} y {enemy2.name}")
        return battle_id
    
    def _get_entity_at_position(self, battle, position):
        """Busca entidad en posici√≥n"""
        for entity in battle.get_entities():
            if entity.position == position:
                return entity
        return None
    
    def _position_to_screen(self, position: Position) -> tuple:
        """Convierte posici√≥n del grid a coordenadas de pantalla"""
        x = self.renderer.grid_offset[0] + position.x * self.renderer.cell_size
        y = self.renderer.grid_offset[1] + position.y * self.renderer.cell_size
        return (x, y)
    
    def _handle_end_turn_command(self):
        """Termina el turno y limpia estado"""
        try:
            events = self.turn_service.end_player_turn(self.current_battle_id)
            print("üîö Turno terminado")
            for event in events:
                print(f"üì¢ {type(event).__name__}")
            
            # Limpiar estado
            self._clear_selection()
            
        except Exception as e:
            print(f"‚ùå Error al terminar turno: {e}")
    
    def _handle_reset_command(self):
        """Reinicia la batalla"""
        self.current_battle_id = self._create_initial_battle()
        self._clear_selection()
        print("üîÑ Batalla reiniciada")
from enum import Enum, auto
from dataclasses import dataclass
from typing import Optional, List
from core.domain.entities.value_objects.entity_id import EntityId
from core.domain.entities.value_objects.position import Position

class GameState(Enum):
    """Estados del juego seg√∫n tu GDD"""
    IDLE = auto()                    # Nada seleccionado - esperando input
    ENTITY_SELECTED = auto()         # Entidad seleccionada, mostrando men√∫ de acciones
    TRACING_ROUTE = auto()           # Modo trazado de ruta activo
    TARGETING_ABILITY = auto()       # Seleccionando objetivo para habilidad
    AWAITING_CONFIRMATION = auto()   # Esperando confirmaci√≥n de acci√≥n

@dataclass
class GameContext:
    """Contexto actual del juego - estado compartido"""
    current_state: GameState = GameState.IDLE
    selected_entity_id: Optional[EntityId] = None
    current_route: Optional[List[Position]] = None
    dash_anchors: List[Position] = None  # ‚úÖ NUEVO: Puntos de anclaje para embestidas
    current_destination: Optional[Position] = None  # ‚úÖ NUEVO: Destino actual del cursor
    pending_action: Optional[str] = None  # "move", "attack", "ability_alpha", etc.

    def __post_init__(self):
        if self.dash_anchors is None:
            self.dash_anchors = []

    def reset(self):
        """Resetea el contexto al estado inicial"""
        self.current_state = GameState.IDLE
        self.selected_entity_id = None
        self.current_route = None
        self.dash_anchors.clear()
        self.current_destination = None
        self.pending_action = None

    def get_full_route_points(self) -> List[Position]:
        """Obtiene todos los puntos de la ruta completa: inicio + anclajes + destino"""
        points = []
        if self.selected_entity_id and self.dash_anchors:
            # Esto se calcular√° din√°micamente en el GameLoop
            pass
        return points

    def can_perform_action(self, action_type: str, entity) -> bool:
        """Verifica si una acci√≥n puede realizarse seg√∫n tu GDD"""
        return action_type not in entity.actions_used_this_turn
"""
SERVICIO DE INPUT - Solo maneja entrada de usuario
"""
import pygame
from typing import Optional, Tuple

class InputService:
    """Maneja exclusivamente input del usuario"""
    
    def __init__(self):
        self.mouse_pos = (0, 0)
        self.mouse_clicked = False
        self.keys_pressed = set()
    
    def process_events(self):
        """Procesa eventos de Pygame - Asegurar que mouse_pos se actualiza siempre"""
        self.mouse_clicked = False
        self.keys_pressed.clear()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.keys_pressed.add("QUIT")
            elif event.type == pygame.MOUSEMOTION:
                self.mouse_pos = event.pos
                # ‚úÖ DEBUG: Ver que se est√° actualizando
                # print(f"üñ±Ô∏è  Mouse movido a: {event.pos}")  # Descomenta si necesitas m√°s debug
            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                self.mouse_clicked = True
                print(f"üñ±Ô∏è  Click en: {self.mouse_pos}")  # DEBUG
            elif event.type == pygame.KEYDOWN:
                self._handle_keydown(event)
    
    def _handle_keydown(self, event):
        """Mapea teclas a comandos"""
        key_map = {
            pygame.K_ESCAPE: "ESCAPE",
            pygame.K_SPACE: "SPACE", 
            pygame.K_r: "RESET",
            pygame.K_1: "ABILITY_1",
            pygame.K_2: "ABILITY_2",
            pygame.K_RETURN: "ENTER"
        }
        
        if event.key in key_map:
            self.keys_pressed.add(key_map[event.key])
    
    def get_mouse_grid_position(self, grid_offset: Tuple[int, int], cell_size: int, grid_size: Tuple[int, int]) -> Optional[Tuple[int, int]]:
        """Convierte coordenadas de pantalla a grid"""
        screen_x, screen_y = self.mouse_pos
        grid_x = (screen_x - grid_offset[0]) // cell_size
        grid_y = (screen_y - grid_offset[1]) // cell_size
        
        # Validar l√≠mites del grid
        if (0 <= grid_x < grid_size[0] and 0 <= grid_y < grid_size[1]):
            return (grid_x, grid_y)
        return None
    
    def is_key_pressed(self, key: str) -> bool:
        return key in self.keys_pressed
    
    def is_mouse_clicked(self) -> bool:
        return self.mouse_clicked
    
    def get_mouse_position(self) -> Tuple[int, int]:
        return self.mouse_pos
    
    def get_mouse_grid_position(self, grid_offset: Tuple[int, int], cell_size: int, grid_size: Tuple[int, int]) -> Optional[Tuple[int, int]]:
        """Convierte coordenadas de pantalla a grid"""
        screen_x, screen_y = self.mouse_pos
        grid_x = (screen_x - grid_offset[0]) // cell_size
        grid_y = (screen_y - grid_offset[1]) // cell_size
        
        # Validar l√≠mites del grid
        if (0 <= grid_x < grid_size[0] and 0 <= grid_y < grid_size[1]):
            return (grid_x, grid_y)
        return None
import pygame
from typing import List, Optional
from core.domain.entities.value_objects.position import Position
from core.domain.entities.battle_entity import BattleEntity
from core.domain.services.route_system import MovementRoute
from core.domain.entities.value_objects.entity_id import EntityId

class MovementVisualizer:
    """Renderiza rutas din√°micas con soporte para embestidas manuales"""

    def __init__(self, grid_offset: tuple, cell_size: int, grid_size: tuple):
        self.grid_offset = grid_offset
        self.cell_size = cell_size
        self.grid_size = grid_size
        
        # Colores mejorados
        self.colors = {
            "valid_route": (100, 200, 100),      # Verde
            "invalid_route": (255, 165, 0),      # Naranja  
            "dash_target": (255, 50, 50),        # Rojo para enemigos detectados
            "marked_dash_target": (255, 0, 0),   # Rojo intenso para marcados manualmente
            "route_line": (255, 255, 255, 180),  # L√≠nea blanca semitransparente
            "path_node": (200, 230, 255, 150),   # Nodos de ruta azul claro
        }

    def render_route(self, screen: pygame.Surface, route: Optional[MovementRoute], 
                    current_position: Position, is_dragging: bool = False,
                    dash_anchors: List[Position] = None) -> None:
        """Renderiza ruta con puntos de anclaje especiales"""
        if not route or not route.path:
            return
        
        if dash_anchors is None:
            dash_anchors = []
        
        route_color = self.colors["valid_route"] if route.is_valid else self.colors["invalid_route"]
        
        # 1. Renderizar l√≠nea de ruta principal
        self._render_route_line(screen, current_position, route.path, route_color)
        
        # 2. Renderizar puntos de anclaje con numeraci√≥n
        for i, anchor_pos in enumerate(dash_anchors):
            anchor_screen = self._position_to_screen(anchor_pos)
            
            # C√≠rculo especial para anclajes
            pygame.draw.circle(screen, (255, 0, 0), anchor_screen, 12, 3)
            
            # N√∫mero de anclaje
            font = pygame.font.Font(None, 18)
            text = font.render(str(i+1), True, (255, 255, 255))
            text_rect = text.get_rect(center=anchor_screen)
            screen.blit(text, text_rect)
            
            # Icono de espada en anclajes
            self._render_sword_icon(screen, anchor_screen, is_anchor=True)

    def _render_route_line(self, screen: pygame.Surface, start_pos: Position, 
                          path: List[Position], color: tuple) -> None:
        """Renderiza la l√≠nea continua de la ruta"""
        if not path:
            return
            
        # Convertir posiciones a coordenadas de pantalla
        screen_points = []
        
        # Punto inicial (posici√≥n actual de la entidad)
        start_screen = self._position_to_screen(start_pos)
        screen_points.append(start_screen)
        
        # Puntos de la ruta
        for pos in path:
            screen_pos = self._position_to_screen(pos)
            screen_points.append(screen_pos)
        
        # Dibujar l√≠neas conectadas
        if len(screen_points) > 1:
            pygame.draw.lines(screen, color, False, screen_points, 3)
            
            # Dibujar punto final m√°s grande
            end_pos = screen_points[-1]
            pygame.draw.circle(screen, color, end_pos, 8)

    def _render_path_nodes(self, screen: pygame.Surface, path: List[Position]) -> None:
        """Renderiza nodos individuales del camino"""
        for i, pos in enumerate(path):
            screen_pos = self._position_to_screen(pos)
            
            # Dibujar c√≠rculo en cada nodo (excepto el √∫ltimo que ya tiene uno grande)
            if i < len(path) - 1:
                pygame.draw.circle(screen, self.colors["path_node"], screen_pos, 5)
                
                # N√∫mero de paso (opcional)
                font = pygame.font.Font(None, 20)
                text = font.render(str(i+1), True, (255, 255, 255))
                text_rect = text.get_rect(center=(screen_pos[0], screen_pos[1] - 15))
                screen.blit(text, text_rect)

    def _render_dash_targets(self, screen: pygame.Surface, dash_targets: List[BattleEntity], 
                           marked_dash_targets: List[EntityId], route_color: tuple) -> None:
        """Renderiza enemigos para embestida diferenciando marcados manualmente"""
        for target in dash_targets:
            target_screen = self._position_to_screen(target.position)
            
            # Determinar color y tama√±o seg√∫n si est√° marcado manualmente
            if target.id in marked_dash_targets:
                color = self.colors["marked_dash_target"]  # Rojo intenso
                radius = self.cell_size // 2 + 10
                pulse = abs(pygame.time.get_ticks() % 1000 - 500) / 500  # Efecto pulsante
                radius = int(radius * (0.8 + pulse * 0.2))
            else:
                color = self.colors["dash_target"]  # Rojo normal
                radius = self.cell_size // 2 + 5
            
            # C√≠rculo alrededor del enemigo
            pygame.draw.circle(screen, color, target_screen, radius, 3)
            
            # L√≠nea conectada desde la ruta al enemigo
            # Corregido: pasar la ruta de posiciones, no la lista de entidades
            route_positions = [t.position if hasattr(t, 'position') else t for t in dash_targets]
            closest_route_point = self._find_closest_route_point(target.position, route_positions)
            if closest_route_point:
                route_screen = self._position_to_screen(closest_route_point)
                pygame.draw.line(screen, color, route_screen, target_screen, 2)
            
            # Icono de espada (m√°s grande si est√° marcado)
            self._render_sword_icon(screen, target_screen, target.id in marked_dash_targets)

    def _render_dash_damage_info(self, screen: pygame.Surface, route: MovementRoute, 
                               marked_dash_targets: List[EntityId]) -> None:
        """Renderiza tooltip con informaci√≥n de da√±o diferenciando embestidas manuales"""
        if not route.dash_targets:
            return
            
        # Calcular da√±o de embestidas marcadas vs autom√°ticas
        auto_dash_count = len([t for t in route.dash_targets if t.id not in marked_dash_targets])
        manual_dash_count = len([t for t in route.dash_targets if t.id in marked_dash_targets])
        total_damage = len(route.dash_targets) * 15
        
        # Posicionar en la parte superior de la pantalla
        info_x, info_y = 400, 30
        
        # Fondo semitransparente
        info_bg = pygame.Surface((250, 80), pygame.SRCALPHA)
        info_bg.fill((40, 40, 60, 200))
        screen.blit(info_bg, (info_x - 10, info_y - 10))
        
        # Texto de informaci√≥n
        font = pygame.font.Font(None, 22)
        
        if manual_dash_count > 0:
            manual_text = f"Embestidas MANUALES: {manual_dash_count}"
            manual_surface = font.render(manual_text, True, (255, 100, 100))
            screen.blit(manual_surface, (info_x, info_y))
            
        if auto_dash_count > 0:
            auto_text = f"Embestidas AUTOM√ÅTICAS: {auto_dash_count}"
            auto_surface = font.render(auto_text, True, (255, 200, 200))
            screen.blit(auto_surface, (info_x, info_y + 20))
        
        damage_text = f"Da√±o total: {total_damage}"
        damage_surface = font.render(damage_text, True, (255, 255, 255))
        screen.blit(damage_surface, (info_x, info_y + 45))

    def _render_sword_icon(self, screen: pygame.Surface, position: tuple, is_anchor: bool = False):
        """Renderiza icono de espada (especial para anclajes)"""
        x, y = position
        size = 1.8 if is_anchor else 1.0  # M√°s grande para anclajes
        
        # Espada m√°s detallada para anclajes
        points = [
            (x, y - 10 * size),                    # Punta
            (x - 3 * size, y - 3 * size),          # Guarda izquierda
            (x - 5 * size, y + 5 * size),          # Base izquierda  
            (x - 2 * size, y + 6 * size),          # Empu√±adura izquierda
            (x + 2 * size, y + 6 * size),          # Empu√±adura derecha
            (x + 5 * size, y + 5 * size),          # Base derecha
            (x + 3 * size, y - 3 * size),          # Guarda derecha
        ]
        
        color = (255, 255, 0) if is_anchor else (255, 255, 255)  # Amarillo para anclajes
        pygame.draw.polygon(screen, color, points)
        pygame.draw.polygon(screen, (200, 200, 0), points, 1)

    def _position_to_screen(self, position: Position) -> tuple:
        """Convierte posici√≥n del grid a coordenadas de pantalla"""
        x = self.grid_offset[0] + position.x * self.cell_size + self.cell_size // 2
        y = self.grid_offset[1] + position.y * self.cell_size + self.cell_size // 2
        return (x, y)
    
    def _find_closest_route_point(self, target_pos: Position, route_path: List[Position]) -> Optional[Position]:
        """Encuentra el punto de ruta m√°s cercano REALMENTE"""
        if not route_path:
            return None
            
        closest_point = None
        min_distance = float('inf')
        
        for route_pos in route_path:
            distance = target_pos.distance_to(route_pos)
            if distance < min_distance:
                min_distance = distance
                closest_point = route_pos
        
        # Solo retornar si est√° suficientemente cerca (ad-yacente)
        return closest_point if min_distance <= 1 else None

    def _render_dash_connections(self, screen: pygame.Surface, dash_targets: List[BattleEntity], 
                            route_path: List[Position], color: tuple):
        """Renderiza conexiones entre ruta y enemigos embestidos"""
        for target in dash_targets:
            closest_route_point = self._find_closest_route_point(target.position, route_path)
            if closest_route_point:
                target_screen = self._position_to_screen(target.position)
                route_screen = self._position_to_screen(closest_route_point)
                
                # L√≠nea punteada para conexi√≥n
                self._draw_dashed_line(screen, color, route_screen, target_screen, dash_length=8)
                
                # Punto de conexi√≥n en la ruta
                pygame.draw.circle(screen, color, route_screen, 6, 2)

    def _draw_dashed_line(self, screen: pygame.Surface, color: tuple, start: tuple, end: tuple, dash_length: int = 5):
        """Dibuja una l√≠nea punteada"""
        dx = end[0] - start[0]
        dy = end[1] - start[1]
        distance = max(1, (dx**2 + dy**2)**0.5)
        dashes = int(distance / dash_length)
        
        for i in range(dashes):
            start_percent = i / dashes
            end_percent = (i + 0.5) / dashes  # Mitad del dash para crear el espacio
            
            start_x = start[0] + dx * start_percent
            start_y = start[1] + dy * start_percent
            end_x = start[0] + dx * end_percent  
            end_y = start[1] + dy * end_percent
            
            pygame.draw.line(screen, color, (start_x, start_y), (end_x, end_y), 2)
"""
SERVICIO DE RENDERIZADO - Con imports ABSOLUTOS
"""
import pygame
from typing import List, Optional
from core.domain.entities.value_objects.position import Position
from core.domain.entities.value_objects.game_enums import Team

class RenderingService:
    """Servicio de renderizado especializado"""
    
    def __init__(self, screen_width: int = 800, screen_height: int = 600):
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.screen = None
        self.clock = pygame.time.Clock()
        self.font = None
        self.big_font = None
        
        self.colors = {
            "background": (25, 25, 40),
            "grid": (60, 60, 80),
            "grid_highlight": (100, 100, 150),
            "player": (65, 105, 225),
            "enemy": (220, 20, 60),
            "obstacle": (100, 100, 100),
            "text": (255, 255, 255),
            "ui_background": (40, 40, 60, 200),
            "health_bar": (50, 200, 50),
            "ph_bar": (30, 144, 255),
            "selected": (255, 255, 0),
            "valid_move": (100, 200, 100, 100),
            "player_turn": (100, 255, 100),
            "enemy_turn": (255, 100, 100),
        }
        
        self.grid_size = (8, 8)
        self.cell_size = 60
        self.grid_offset = (100, 100)
    
    def initialize(self) -> None:
        """Inicializa Pygame y recursos gr√°ficos"""
        pygame.init()
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
        pygame.display.set_caption("FRACTALS - Arquitectura Limpia")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 24)
        self.big_font = pygame.font.Font(None, 32)
        
        print("üé® Renderizador inicializado")
    
    def render_battle(self, battle, selected_entity_id: Optional[str] = None, valid_moves: List[Position] = None) -> None:
        """Renderiza el estado completo de la batalla"""
        self.screen.fill(self.colors["background"])

        # Renderizar elementos en orden
        self._render_grid()
        self._render_valid_moves(valid_moves)

        for obstacle in battle._obstacles:
            self._render_obstacle(obstacle)

        for entity in battle._entities.values():
            is_selected = entity.id == selected_entity_id
            self._render_entity(entity, is_selected)

        self._render_ui(battle)

        pygame.display.flip()
        self.clock.tick(60)
    
    def _render_grid(self) -> None:
        """Renderiza el grid t√°ctico"""
        for x in range(self.grid_size[0] + 1):
            pygame.draw.line(
                self.screen, self.colors["grid"],
                (self.grid_offset[0] + x * self.cell_size, self.grid_offset[1]),
                (self.grid_offset[0] + x * self.cell_size, self.grid_offset[1] + self.grid_size[1] * self.cell_size)
            )
        for y in range(self.grid_size[1] + 1):
            pygame.draw.line(
                self.screen, self.colors["grid"],
                (self.grid_offset[0], self.grid_offset[1] + y * self.cell_size),
                (self.grid_offset[0] + self.grid_size[0] * self.cell_size, self.grid_offset[1] + y * self.cell_size)
            )
    
    def _render_valid_moves(self, valid_moves: List[Position]) -> None:
        """Renderiza las posiciones de movimiento v√°lidas"""
        if not valid_moves:
            return
            
        for pos in valid_moves:
            screen_x = self.grid_offset[0] + pos.x * self.cell_size
            screen_y = self.grid_offset[1] + pos.y * self.cell_size
            
            # Crear superficie semitransparente
            highlight = pygame.Surface((self.cell_size - 10, self.cell_size - 10), pygame.SRCALPHA)
            highlight.fill(self.colors["valid_move"])
            self.screen.blit(highlight, (screen_x + 5, screen_y + 5))
    
    def _render_entity(self, entity, is_selected: bool = False) -> None:
        """Renderiza una entidad en el grid"""
        pos = entity.position
        team = entity.team

        print(f"üîç RENDER_ENTITY DEBUG:")
        print(f"   - Nombre: {entity.name}")
        print(f"   - Team: {team} (tipo: {type(team)})")
        print(f"   - Team value: {team.value if hasattr(team, 'value') else 'N/A'}")
        print(f"   - Team == Team.PLAYER: {team == Team.PLAYER}")
        print(f"   - Team == 'player': {team == 'player'}")
        print(f"   - Team == Team.ENEMY: {team == Team.ENEMY}")
        print(f"   - Team == 'enemy': {team == 'enemy'}")

        screen_x = self.grid_offset[0] + pos.x * self.cell_size
        screen_y = self.grid_offset[1] + pos.y * self.cell_size

        color = None
        if team == Team.PLAYER:
            color = self.colors["player"]
            print(f"   - COLOR: AZUL (Player)")
        elif team == Team.ENEMY:
            color = self.colors["enemy"] 
            print(f"   - COLOR: ROJO (Enemy)")
        else:
            # Fallback por si acaso
            color = self.colors["enemy"]
            print(f"   - COLOR: ROJO (Fallback - team desconocido: {team})")

        if team == Team.PLAYER or (isinstance(team, str) and team.upper() == "PLAYER"):
            color = self.colors["player"]
        else:
            color = self.colors["enemy"]

        # Dibujar entidad
        radius = self.cell_size // 3
        pygame.draw.circle(self.screen, color, (screen_x + self.cell_size//2, screen_y + self.cell_size//2), radius)

        # Resaltar si est√° seleccionada
        if is_selected:
            pygame.draw.circle(self.screen, self.colors["selected"],
                             (screen_x + self.cell_size//2, screen_y + self.cell_size//2),
                             radius + 2, 2)  # Borde amarillo

        # Barra de salud
        health_percent = entity.stats.current_hp / entity.stats.max_hp
        bar_width = self.cell_size - 10
        bar_height = 6

        # Fondo barra
        pygame.draw.rect(self.screen, (100, 100, 100),
                        (screen_x + 5, screen_y - 10, bar_width, bar_height))
        # Salud actual
        pygame.draw.rect(self.screen, self.colors["health_bar"],
                        (screen_x + 5, screen_y - 10, int(bar_width * health_percent), bar_height))

        # Nombre de la entidad
        name_surface = self.font.render(entity.name, True, self.colors["text"])
        name_rect = name_surface.get_rect(center=(screen_x + self.cell_size//2, screen_y - 25))
        self.screen.blit(name_surface, name_rect)
    
    def _render_obstacle(self, position: Position) -> None:
        """Renderiza un obst√°culo"""
        screen_x = self.grid_offset[0] + position.x * self.cell_size
        screen_y = self.grid_offset[1] + position.y * self.cell_size
        
        pygame.draw.rect(
            self.screen, self.colors["obstacle"],
            (screen_x + 5, screen_y + 5, self.cell_size - 10, self.cell_size - 10)
        )
    
    def _render_ui(self, battle) -> None:
        """Renderiza la interfaz de usuario actualizada con enums"""

        turn_color = self.colors["player_turn"] if battle.current_turn == Team.PLAYER else self.colors["enemy_turn"]
        turn_text = f"TURNO: {'JUGADOR' if battle.current_turn == Team.PLAYER else 'ENEMIGO'}"
        turn_surface = self.big_font.render(turn_text, True, turn_color)
        self.screen.blit(turn_surface, (20, 20))

        info_lines = [
            f"Acciones: {battle.actions_remaining}/3",
            f"Turno: {battle.turn_count}",
            f"Modo: {battle.mode}",
            f"Jugadores: {len(battle.get_player_entities())} | Enemigos: {len(battle.get_enemy_entities())}"
        ]
        for i, line in enumerate(info_lines):
            info_surface = self.font.render(line, True, self.colors["text"])
            self.screen.blit(info_surface, (20, 60 + i * 25))
        controls = [
            "CONTROLES:",
            "CLICK - Seleccionar/Mover entidad", 
            "ESPACIO - Terminar turno",
            "R - Reiniciar batalla",
            "ESC - Salir"
        ]
        for i, control in enumerate(controls):
            control_surface = self.font.render(control, True, self.colors["text"])
            self.screen.blit(control_surface, (500, 20 + i * 25))
    
    def cleanup(self) -> None:
        """Limpia recursos de Pygame"""
        try:
            pygame.quit()
        except:
            pass
# REEMPLAZAR el contenido completo
from .game_loop import GameLoop
from .input_service import InputService
from .rendering_service import RenderingService
from .enhanced_rendering_service import EnhancedRenderingService

__all__ = [
    "GameLoop", 
    "InputService", 
    "RenderingService",
    "EnhancedRenderingService"
]
# Battle View
# Entity View
